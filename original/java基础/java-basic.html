

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>java基础 [ Swithun Blog ]</title>

  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/lib/font-awesome-4.7.0/css/font-awesome.min.css">
  
  <link rel="stylesheet" href="/lib/highlight-11-9-0/src/styles/atom-one-dark.css">
  
  <link rel="stylesheet" href="/css/again.css">
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>

  <!-- menu -->
  <div id="menu-outer">
    <div id="menu-inner">
      
      <a class="menu-button" href="/">Home</a>
      
      <a class="menu-button" href="/about">About</a>
      
      <a class="menu-button" href="/contact">Contact</a>
      
      <a class="menu-button" href="/archives">Archives</a>
      
      <a class="menu-button" href="/categories">Category</a>
      
    </div>
  </div>

  <!-- 中间主体 -->
  <div id="main">
    <!-- 侧边栏 -->
    <div id="aside-outer">
      <aside>
        <!-- 搜索栏 -->
<div id="search">
    <input class="search-input" type="text" placeholder="search">
    <i id="search-icon" class="fa fa-bars" title="切换目录与索引"></i>
</div>

<!-- 侧边目录栏 -->
<div id="tree">
    

    

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            Android
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/18/Android/Fragment原理/">
                            <i class="fa fa-file"></i>
                            Fragment原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/Android/viewmodel原理/">
                            <i class="fa fa-file"></i>
                            viewmodel原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/03/03/Android/view绘制原理/">
                            <i class="fa fa-file"></i>
                            view绘制原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/03/09/Android/自定义View实现拖拽展开面板/">
                            <i class="fa fa-file"></i>
                            自定义View实现拖拽展开面板
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/05/12/Android/NestedScrolling原理/">
                            <i class="fa fa-file"></i>
                            NestedScrolling原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/05/25/Android/自己实现一个NestedScrollView/">
                            <i class="fa fa-file"></i>
                            自己实现一个NestedScrollView
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/06/02/Android/EditText光标定位原理/">
                            <i class="fa fa-file"></i>
                            EditText光标定位原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/06/02/Android/一步步解决NestedScrollView嵌套EditText的冲突/">
                            <i class="fa fa-file"></i>
                            一步步解决NestedScrollView嵌套EditText的冲突
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/06/11/Android/Dialog原理/">
                            <i class="fa fa-file"></i>
                            Dialog原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/07/20/Android/从0实现一个BottomSheetDialog/">
                            <i class="fa fa-file"></i>
                            从0实现一个BottomSheetDialog
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/08/18/Android/kotlin协程原理/">
                            <i class="fa fa-file"></i>
                            kotlin协程原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/09/07/Android/textview measure流程/">
                            <i class="fa fa-file"></i>
                            textview measure流程
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/03/10/Android/Activity的启动流程/">
                            <i class="fa fa-file"></i>
                            Activity的启动流程
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            主题演示
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/主题演示/demo1/">
                            <i class="fa fa-file"></i>
                            demo1
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/22/主题演示/temp/">
                            <i class="fa fa-file"></i>
                            temp
                        </a>
                    </li>
                </ul>

              

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            demo_folder_level2
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/主题演示/demo_folder_level2/demo2/">
                            <i class="fa fa-file"></i>
                            demo2
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            AOSP
                        </a>
                        

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            java
                        </a>
                        

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            lang
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/10/07/AOSP/java/lang/ThreadLocal/">
                            <i class="fa fa-file"></i>
                            ThreadLocal
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2025/01/04/AOSP/java/lang/Thread/">
                            <i class="fa fa-file"></i>
                            Thread
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            util
                        </a>
                        

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            concurrent
                        </a>
                        

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            ThreadPoolExecutor
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/01/04/AOSP/java/util/concurrent/ThreadPoolExecutor/Worker/">
                            <i class="fa fa-file"></i>
                            Worker
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/12/28/AOSP/java/util/concurrent/LinkedBlockingQueue/">
                            <i class="fa fa-file"></i>
                            LinkedBlockingQueue
                        </a>
                    </li>
                </ul>

              

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            sub-ThreadPoolExecutor
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/01/04/AOSP/java/util/concurrent/sub-ThreadPoolExecutor/Worker/">
                            <i class="fa fa-file"></i>
                            Worker
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            locks
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2025/01/11/AOSP/java/util/concurrent/locks/Condition/">
                            <i class="fa fa-file"></i>
                            Condition
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            multi_thread
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/12/08/multi_thread/Test/">
                            <i class="fa fa-file"></i>
                            Test
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/12/08/multi_thread/ThreadPool/">
                            <i class="fa fa-file"></i>
                            ThreadPool
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2025/01/04/multi_thread/Java锁/">
                            <i class="fa fa-file"></i>
                            Java锁
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            面试
                        </a>
                        

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            Handler
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2025/10/18/面试/Handler/handler/">
                            <i class="fa fa-file"></i>
                            handler
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            GC
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2025/11/16/面试/GC/GC/">
                            <i class="fa fa-file"></i>
                            GC
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            HashMap
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2025/10/26/面试/HashMap/HashMap面试/">
                            <i class="fa fa-file"></i>
                            HashMap面试
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            java基础
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2025/03/02/java基础/java-basic/">
                            <i class="fa fa-file"></i>
                            java-basic
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 
</div>

<div id="toc" style="display: none;"></div>
      </aside>
    </div>
    <!-- 文章内容 -->
    <div id="content-outer">
      <div id="content-inner">
        
<article id="page">
  <h1>java基础</h1>
  <h2 id="JVM-JRE-JDK"><a href="#JVM-JRE-JDK" class="headerlink" title="JVM &amp; JRE &amp; JDK"></a>JVM &amp; JRE &amp; JDK</h2><h3 id=""><a href="#" class="headerlink" title="&lt;Java9"></a>&lt;Java9</h3><pre class="mermaid">flowchart TD
    subgraph JDK["[**JDK**]Java Development Kit"]
        direction TB
        subgraph Tools["开发工具"]
            F[javac 编译器]
            G[jdb 调试器]
            H[Javadoc 文档生成器]
            I[JConsole 监控工具]
            J[Javap 反编译工具]
        end
        subgraph JRE["[**JRE**]Java Runtime Environment"]
            direction TB
            subgraph JVM["[**JVM**]Java Virtual Machine"]
                direction LR
                A[Class Loader]
                B[Runtime Data Areas]
                C[Execution Engine]
                D[Native Method Interface]
            end
            E[Class Library]
        end
    end

    style JDK fill:#5E275133,stroke:#333,stroke-width:4px
    style Tools fill:#7D55C733,stroke:#333,stroke-width:4px
    style JRE fill:#7D55C733,stroke:#333,stroke-width:4px
    style JVM fill:#FF7F3233,stroke:#333,stroke-width:4px</pre>

<h3 id="Java9"><a href="#Java9" class="headerlink" title="&gt;&#x3D;Java9"></a>&gt;&#x3D;Java9</h3><pre class="mermaid">flowchart TD
    subgraph JDK["[**JDK**] Java Development Kit (Modular)"]
        direction TB
        subgraph Tools["开发工具"]
            F[javac 编译器]
            G[jdb 调试器]
            H[Javadoc 文档生成器]
            I[JConsole 监控工具]
            J[Javap 反编译工具]
            K[jlink 工具]
        end
        subgraph CustomRuntime["[**Custom Runtime**] via jlink"]
            direction TB
            subgraph JVM["[**JVM**] Java Virtual Machine"]
                direction LR
                A[Class Loader]
                B[Runtime Data Areas]
                C[Execution Engine]
                D[Native Method Interface]
            end
            E[Required Modules]
        end
    end

    style JDK fill:#5E275133,stroke:#333,stroke-width:4px
    style Tools fill:#7D55C733,stroke:#333,stroke-width:4px
    style CustomRuntime fill:#9A8CE633,stroke:#333,stroke-width:4px
    style JVM fill:#FF7F3233,stroke:#333,stroke-width:4px</pre>


<h2 id="横竖屏切换时候Activity的生命周期"><a href="#横竖屏切换时候Activity的生命周期" class="headerlink" title="横竖屏切换时候Activity的生命周期"></a>横竖屏切换时候Activity的生命周期</h2><h3 id="默认流程（未配置-configChanges-时）"><a href="#默认流程（未配置-configChanges-时）" class="headerlink" title="默认流程（未配置 configChanges 时）"></a><strong>默认流程（未配置 <code>configChanges</code> 时）</strong></h3><ol>
<li><p><strong>当前 Activity 销毁：</strong><br>• <code>onPause()</code> → <code>onStop()</code> → <code>onDestroy()</code><br>• 在 <code>onDestroy()</code> 前会调用 <code>onSaveInstanceState(Bundle)</code> 保存临时数据。</p>
</li>
<li><p><strong>新的 Activity 创建：</strong><br>• <code>onCreate(Bundle)</code> → <code>onStart()</code> → <code>onRestoreInstanceState(Bundle)</code> → <code>onResume()</code><br>• 通过 <code>Bundle</code> 恢复之前保存的状态。</p>
</li>
</ol>
<hr>
<h3 id="关键方法说明"><a href="#关键方法说明" class="headerlink" title="关键方法说明"></a><strong>关键方法说明</strong></h3><p>• <strong><code>onSaveInstanceState(Bundle)</code></strong><br>  在 Activity 销毁前调用，保存临时数据（如文本框内容）。</p>
<p>• <strong><code>onRestoreInstanceState(Bundle)</code></strong><br>  在 <code>onStart()</code> 后调用，恢复保存的数据（比在 <code>onCreate()</code> 中恢复更明确）。</p>
<hr>
<h3 id="避免-Activity-重建的方法"><a href="#避免-Activity-重建的方法" class="headerlink" title="避免 Activity 重建的方法"></a><strong>避免 Activity 重建的方法</strong></h3><p>如果不想让 Activity 在横竖屏切换时重建，可以通过 <code>AndroidManifest.xml</code> 配置 <code>configChanges</code>：</p>
<pre><code class="xml">&lt;activity
    android:name=&quot;.YourActivity&quot;
    android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot; /&gt;
</code></pre>
<p>• **API 13+ 必须包含 <code>screenSize</code>**（因为屏幕尺寸变化也被视为配置变更）。</p>
<p>此时，横竖屏切换会触发：</p>
<ol>
<li><strong><code>onConfigurationChanged(Configuration)</code></strong><br>开发者需在此方法中手动调整 UI（例如加载横屏布局）。</li>
</ol>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>临时数据保存：</strong><br>即使阻止了 Activity 重建，仍需处理动态数据（如网络请求），因为系统可能因内存不足回收 Activity。</p>
</li>
<li><p><strong>开发建议：</strong><br>• <strong>默认行为更安全</strong>：让系统重建 Activity，简化布局适配。<br>• <strong>手动处理需谨慎</strong>：仅在对性能敏感或特殊需求时使用 <code>configChanges</code>。</p>
</li>
</ol>
<hr>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><pre><code class="java">// 1. 保存数据
@Override
protected void onSaveInstanceState(Bundle outState) &#123;
    super.onSaveInstanceState(outState);
    outState.putString(&quot;key&quot;, &quot;value&quot;);
&#125;

// 2. 恢复数据（两种方式）
// 方式一：在 onCreate() 中恢复
@Override
protected void onCreate(Bundle savedInstanceState) &#123;
    super.onCreate(savedInstanceState);
    if (savedInstanceState != null) &#123;
        String value = savedInstanceState.getString(&quot;key&quot;);
    &#125;
&#125;

// 方式二：在 onRestoreInstanceState() 中恢复
@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) &#123;
    super.onRestoreInstanceState(savedInstanceState);
    String value = savedInstanceState.getString(&quot;key&quot;);
&#125;

// 3. 配置变更时手动处理
@Override
public void onConfigurationChanged(Configuration newConfig) &#123;
    super.onConfigurationChanged(newConfig);
    if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;
        // 加载横屏布局
    &#125; else &#123;
        // 加载竖屏布局
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th>场景</th>
<th>生命周期调用顺序</th>
<th>数据保存与恢复</th>
</tr>
</thead>
<tbody><tr>
<td>默认行为（重建 Activity）</td>
<td><code>onPause()</code> → <code>onStop()</code> → <code>onDestroy()</code> → <code>onCreate()</code> → <code>onStart()</code> → <code>onResume()</code></td>
<td>通过 <code>Bundle</code> 保存&#x2F;恢复</td>
</tr>
<tr>
<td>配置 <code>configChanges</code></td>
<td>仅调用 <code>onConfigurationChanged()</code></td>
<td>需手动处理 UI 逻辑</td>
</tr>
</tbody></table>
<h2 id="Java中提供了抽象类还有接口，开发中如何去选择呢？"><a href="#Java中提供了抽象类还有接口，开发中如何去选择呢？" class="headerlink" title="Java中提供了抽象类还有接口，开发中如何去选择呢？"></a>Java中提供了抽象类还有接口，开发中如何去选择呢？</h2><p>在 Java 开发中，<strong>抽象类（Abstract Class）</strong>和<strong>接口（Interface）</strong>都是实现抽象和多态的核心机制，但它们的适用场景和设计目的不同。以下是选择时的核心原则和对比：</p>
<hr>
<h3 id="1-抽象类（Abstract-Class）"><a href="#1-抽象类（Abstract-Class）" class="headerlink" title="1. 抽象类（Abstract Class）"></a><strong>1. 抽象类（Abstract Class）</strong></h3><p><strong>核心特点</strong>：<br>• 可以有 <strong>具体方法（实现代码）</strong> 和 <strong>抽象方法</strong>。<br>• 可以定义 <strong>成员变量</strong>、<strong>构造方法</strong>。<br>• 通过继承实现代码复用，但 Java 是单继承，一个类只能继承一个抽象类。</p>
<p><strong>适用场景</strong>：<br>• <strong>共享代码</strong>：多个子类有<strong>共同的代码逻辑或成员变量</strong>时，用抽象类避免重复。</p>
<pre><code class="java">public abstract class Animal &#123;
    private String name; // 共享成员变量
    
    public Animal(String name) &#123; // 构造方法
        this.name = name;
    &#125;
    
    public void eat() &#123; // 具体方法
        System.out.println(name + &quot; is eating.&quot;);
    &#125;
    
    public abstract void makeSound(); // 抽象方法
&#125;
</code></pre>
<p>• <strong>定义部分实现</strong>：需要为子类提供<strong>默认实现</strong>，同时强制子类实现特定方法。<br>• <strong>控制子类的构造过程</strong>：通过抽象类的构造方法强制子类初始化某些状态。</p>
<hr>
<h3 id="2-接口（Interface）"><a href="#2-接口（Interface）" class="headerlink" title="2. 接口（Interface）"></a><strong>2. 接口（Interface）</strong></h3><p><strong>核心特点</strong>：<br>• 从 Java 8 开始，接口可以包含 <strong>默认方法（<code>default</code>）</strong> 和 <strong>静态方法</strong>，但主要用途仍是定义行为契约。<br>• 一个类可以实现多个接口，实现多继承的效果。<br>• 接口不能定义成员变量（只能定义 <code>public static final</code> 常量），没有构造方法。</p>
<p><strong>适用场景</strong>：<br>• <strong>定义行为契约</strong>：表示“<strong>能做什么</strong>”（如 <code>Runnable</code> 的 <code>run()</code>，<code>Comparable</code> 的 <code>compareTo()</code>）。</p>
<pre><code class="java">public interface Flyable &#123;
    void fly(); // 定义行为契约
    
    default void land() &#123; // 默认方法（Java 8+）
        System.out.println(&quot;Landing...&quot;);
    &#125;
&#125;
</code></pre>
<p>• <strong>实现多态</strong>：让无关的类实现相同的行为（如 <code>Serializable</code>、<code>Cloneable</code>）。<br>• <strong>解耦功能</strong>：通过接口隔离不同模块，遵循 <strong>接口隔离原则（ISP）</strong>。</p>
<hr>
<h3 id="3-如何选择？"><a href="#3-如何选择？" class="headerlink" title="3. 如何选择？"></a><strong>3. 如何选择？</strong></h3><table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码复用</strong></td>
<td>✅ 适合共享代码和状态</td>
<td>❌ 不能共享代码（Java 8 后可通过默认方法部分实现）</td>
</tr>
<tr>
<td><strong>继承关系</strong></td>
<td>表示“<strong>是什么</strong>”（is-a 关系）</td>
<td>表示“<strong>能做什么</strong>”（has-a 关系）</td>
</tr>
<tr>
<td><strong>多继承能力</strong></td>
<td>❌ 单继承</td>
<td>✅ 一个类可实现多个接口</td>
</tr>
<tr>
<td><strong>设计目标</strong></td>
<td>提供基础实现，约束子类结构</td>
<td>定义行为契约，解耦功能模块</td>
</tr>
<tr>
<td><strong>成员变量</strong></td>
<td>✅ 可以定义非静态成员变量</td>
<td>❌ 只能定义常量</td>
</tr>
<tr>
<td><strong>构造方法</strong></td>
<td>✅ 可以定义构造方法</td>
<td>❌ 不能定义构造方法</td>
</tr>
</tbody></table>
<p><strong>实际开发中的选择策略</strong>：</p>
<ol>
<li><p><strong>优先用接口</strong>：<br>• 需要定义<strong>多组无关的行为</strong>（如一个类既能 <code>Fly</code> 又能 <code>Swim</code>）。<br>• 需要实现<strong>多态</strong>，且不依赖共享代码。<br>• 遵循“<strong>面向接口编程</strong>”原则，降低耦合。</p>
</li>
<li><p><strong>用抽象类</strong>：<br>• 多个子类有<strong>共同的代码逻辑或状态</strong>。<br>• 需要提供<strong>部分默认实现</strong>，同时约束子类结构（如模板方法模式）。<br>• 需要<strong>控制子类的构造过程</strong>。</p>
</li>
</ol>
<hr>
<h3 id="4-经典场景示例"><a href="#4-经典场景示例" class="headerlink" title="4. 经典场景示例"></a><strong>4. 经典场景示例</strong></h3><h4 id="1-抽象类示例：模板方法模式"><a href="#1-抽象类示例：模板方法模式" class="headerlink" title="(1) 抽象类示例：模板方法模式"></a><strong>(1) 抽象类示例：模板方法模式</strong></h4><pre><code class="java">public abstract class Game &#123;
    // 模板方法（定义算法骨架）
    public final void play() &#123;
        initialize();
        start();
        end();
    &#125;
    
    protected abstract void initialize();
    protected abstract void start();
    protected void end() &#123; // 默认实现
        System.out.println(&quot;Game over!&quot;);
    &#125;
&#125;

public class Chess extends Game &#123;
    @Override
    protected void initialize() &#123;
        System.out.println(&quot;Chess initialized.&quot;);
    &#125;
    
    @Override
    protected void start() &#123;
        System.out.println(&quot;Chess started.&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="2-接口示例：策略模式"><a href="#2-接口示例：策略模式" class="headerlink" title="(2) 接口示例：策略模式"></a><strong>(2) 接口示例：策略模式</strong></h4><pre><code class="java">public interface PaymentStrategy &#123;
    void pay(int amount);
&#125;

public class CreditCardPayment implements PaymentStrategy &#123;
    @Override
    public void pay(int amount) &#123;
        System.out.println(&quot;Paid &quot; + amount + &quot; via Credit Card.&quot;);
    &#125;
&#125;

public class PayPalPayment implements PaymentStrategy &#123;
    @Override
    public void pay(int amount) &#123;
        System.out.println(&quot;Paid &quot; + amount + &quot; via PayPal.&quot;);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="5-Java-8-的接口默认方法"><a href="#5-Java-8-的接口默认方法" class="headerlink" title="5. Java 8+ 的接口默认方法"></a><strong>5. Java 8+ 的接口默认方法</strong></h3><p>从 Java 8 开始，接口可以定义 <strong>默认方法（<code>default</code>）</strong>，这使得接口也能提供部分实现，但核心设计目的仍不同：</p>
<pre><code class="java">public interface Logger &#123;
    default void log(String message) &#123; // 默认方法
        System.out.println(&quot;Log: &quot; + message);
    &#125;
    
    void error(String message); // 抽象方法
&#125;

public class FileLogger implements Logger &#123;
    @Override
    public void error(String message) &#123;
        System.err.println(&quot;ERROR: &quot; + message);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>• <strong>抽象类</strong>：用于<strong>代码复用和定义类层次结构</strong>（是什么）。<br>• <strong>接口</strong>：用于<strong>定义行为契约和解耦功能</strong>（能做什么）。<br>• <strong>优先使用接口</strong>，尤其是需要多继承或定义行为时；当需要共享代码或状态时，选择抽象类。</p>
<h2 id="Java中在传参数时是将值进行传递，还是传递引用？-如果是kotlin呢"><a href="#Java中在传参数时是将值进行传递，还是传递引用？-如果是kotlin呢" class="headerlink" title="Java中在传参数时是将值进行传递，还是传递引用？ 如果是kotlin呢"></a>Java中在传参数时是将值进行传递，还是传递引用？ 如果是kotlin呢</h2><table>
<thead>
<tr>
<th><strong>语言</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>传递方式</strong></th>
<th><strong>能否通过参数修改原数据</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Java</td>
<td>基本类型（<code>int</code>）</td>
<td>按值传递（副本）</td>
<td>❌</td>
</tr>
<tr>
<td>Java</td>
<td>对象类型</td>
<td>按值传递对象引用的副本</td>
<td>✅ 修改属性有效，重新赋值无效</td>
</tr>
<tr>
<td>Kotlin</td>
<td>基本类型（<code>Int</code>）</td>
<td>按值传递（副本）</td>
<td>❌</td>
</tr>
<tr>
<td>Kotlin</td>
<td>对象类型</td>
<td>按值传递对象引用的副本</td>
<td>✅ 修改属性有效，重新赋值无效</td>
</tr>
</tbody></table>
<hr>
<h3 id="关键结论"><a href="#关键结论" class="headerlink" title="关键结论"></a><strong>关键结论</strong></h3><p>• <strong>Java 和 Kotlin 的参数传递本质都是按值传递</strong>。<br>• <strong>对象类型传递的是引用的副本</strong>，因此可以通过引用修改对象属性，但无法通过参数重新赋值原引用。</p>
<h2 id="Android中为什么主线程不会因为Looper-loop-的死循环导致卡死"><a href="#Android中为什么主线程不会因为Looper-loop-的死循环导致卡死" class="headerlink" title="Android中为什么主线程不会因为Looper.loop()的死循环导致卡死"></a>Android中为什么主线程不会因为Looper.loop()的死循环导致卡死</h2><p>嗯，用户问的是为什么Android的主线程在运行Looper.loop()的死循环时不会卡死。这个问题看起来涉及Android的消息机制和主线程的工作原理。用户可能已经知道Looper.loop()里面有一个无限循环，所以会疑惑为什么这个循环不会导致ANR或者界面卡死。</p>
<p>首先，我需要回顾一下Android的主线程（UI线程）如何处理消息循环。主线程的Looper会不断从消息队列中取出消息并处理，比如处理UI更新、用户输入事件等。那这个死循环本身是不是会导致CPU一直占用，进而卡死呢？</p>
<p>然后想到，这可能涉及到事件驱动模型。在事件驱动的系统中，主线程在没有消息时会进入休眠状态，释放CPU资源，直到有新的消息到来才会被唤醒。也就是说，这个循环并不是一直在空转，而是通过某种机制在无消息时阻塞，避免消耗资源。</p>
<p>接着，应该考虑Linux的epoll机制。Looper可能使用了epoll来管理消息队列，当没有消息时，线程会阻塞在epoll_wait上，这样就不会占用CPU。当有新的消息加入队列时，会通过写入管道文件描述符来唤醒线程，处理消息。这样既保证了实时处理消息，又避免了资源浪费。</p>
<p>另外，ANR的发生是因为主线程在处理某个消息时耗时过长，导致无法及时响应其他事件，比如点击事件或者Activity的生命周期回调。而Looper.loop()本身并不会导致ANR，因为它只是消息循环的框架，真正的问题出在处理单个消息的时间过长。</p>
<p>可能用户混淆了Looper的死循环和ANR的关系，认为死循环本身会导致卡死，但实际上卡死是因为某个消息处理时间太长，而不是循环本身的问题。</p>
<p>还需要解释一下，为什么这个循环不会导致主线程退出。因为主线程的Looper.loop()是无限循环，所以主线程会一直运行，处理消息，直到应用退出。如果没有这个循环，主线程一启动就会结束，无法持续处理事件。</p>
<p>总结的话，应该分点说明：1. 事件驱动模型，阻塞而非空转；2. 使用epoll机制管理消息队列，无消息时休眠；3. ANR的原因不是循环本身，而是消息处理超时；4. 主线程需要持续运行处理事件，因此循环是必要的。</p>
<p>在 Android 中，主线程通过 <code>Looper.loop()</code> 进入一个<strong>无限循环</strong>来持续处理消息，但并不会导致卡死或 ANR（Application Not Responding），其核心原因在于 <strong>事件驱动模型</strong> 和 <strong>Linux 的 epoll 机制</strong>。以下是详细解释：</p>
<hr>
<h3 id="1-主线程的消息循环机制"><a href="#1-主线程的消息循环机制" class="headerlink" title="1. 主线程的消息循环机制"></a><strong>1. 主线程的消息循环机制</strong></h3><h4 id="1-消息队列（MessageQueue）"><a href="#1-消息队列（MessageQueue）" class="headerlink" title="(1) 消息队列（MessageQueue）"></a><strong>(1) 消息队列（MessageQueue）</strong></h4><p>• 主线程的 <code>Looper.loop()</code> 会不断从 <code>MessageQueue</code> 中取出消息（如 UI 更新、触摸事件、生命周期回调等），并分发给对应的 <code>Handler</code> 处理。<br>• <strong>关键流程</strong>：</p>
<pre><code class="java">public static void loop() &#123;
    for (;;) &#123;
        Message msg = queue.next(); // 无消息时阻塞
        if (msg == null) return;    // 只有退出时返回 null
        msg.target.dispatchMessage(msg); // 处理消息
    &#125;
&#125;
</code></pre>
<h4 id="2-阻塞与唤醒"><a href="#2-阻塞与唤醒" class="headerlink" title="(2) 阻塞与唤醒"></a><strong>(2) 阻塞与唤醒</strong></h4><p>• <strong>无消息时阻塞</strong>：当 <code>MessageQueue</code> 为空时，<code>queue.next()</code> 会调用 <code>nativePollOnce()</code>，使线程进入<strong>休眠状态</strong>，释放 CPU 资源。<br>• <strong>有消息时唤醒</strong>：当新消息加入队列时（如点击事件、定时任务等），通过 <code>nativeWake()</code> 唤醒线程继续处理。</p>
<hr>
<h3 id="2-底层原理：Linux-的-epoll-机制"><a href="#2-底层原理：Linux-的-epoll-机制" class="headerlink" title="2. 底层原理：Linux 的 epoll 机制"></a><strong>2. 底层原理：Linux 的 epoll 机制</strong></h3><table>
<thead>
<tr>
<th><strong>关键点</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>事件驱动模型</strong></td>
<td>主线程通过消息队列按顺序处理事件，无消息时休眠，避免空转消耗 CPU。</td>
</tr>
<tr>
<td><strong>epoll 机制</strong></td>
<td>利用 Linux 的 epoll 实现高效阻塞与唤醒，保障线程休眠时释放 CPU。</td>
</tr>
<tr>
<td><strong>ANR 的根源</strong></td>
<td>单条消息处理时间过长，而非消息循环本身。</td>
</tr>
<tr>
<td><strong>无限循环的必要性</strong></td>
<td>保持主线程存活，确保应用持续响应事件。</td>
</tr>
</tbody></table>
<p><strong>核心结论</strong>：<br>主线程的 <code>Looper.loop()</code> 通过高效的消息队列管理和底层阻塞唤醒机制，既保证了实时事件处理，又避免了资源浪费。开发者应避免在主线程执行耗时操作，以预防 ANR。</p>
<h2 id="Handler和Looper的关系"><a href="#Handler和Looper的关系" class="headerlink" title="Handler和Looper的关系"></a>Handler和Looper的关系</h2><p>我们可以用一个 <strong>快递站</strong> 的比喻来理解整个过程，把 Android 的消息机制拆解得更简单：</p>
<hr>
<h3 id="1-快递站的工作流程"><a href="#1-快递站的工作流程" class="headerlink" title="1. 快递站的工作流程"></a><strong>1. 快递站的工作流程</strong></h3><p>想象你开了一个快递站，整个流程是这样的：</p>
<table>
<thead>
<tr>
<th><strong>角色</strong></th>
<th><strong>比喻</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>主线程</strong></td>
<td>快递站</td>
<td>负责处理所有包裹（消息），但一次只能处理一个包裹。</td>
</tr>
<tr>
<td><strong>Looper</strong></td>
<td>传送带</td>
<td>让快递站一直运转，检查有没有新包裹。没有包裹时，传送带暂停（线程休眠）。</td>
</tr>
<tr>
<td><strong>MessageQueue</strong></td>
<td>传送带上的包裹队列</td>
<td>所有包裹按顺序排好队，等待处理。</td>
</tr>
<tr>
<td><strong>Handler</strong></td>
<td>快递员</td>
<td>负责把包裹放到传送带上（发送消息），或者从传送带取下包裹处理（处理消息）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-快递站的一天（流程详解）"><a href="#2-快递站的一天（流程详解）" class="headerlink" title="2. 快递站的一天（流程详解）"></a><strong>2. 快递站的一天（流程详解）</strong></h3><h4 id="1-早晨：快递站开门（主线程启动）"><a href="#1-早晨：快递站开门（主线程启动）" class="headerlink" title="(1) 早晨：快递站开门（主线程启动）"></a><strong>(1) 早晨：快递站开门（主线程启动）</strong></h4><p>• 快递站的传送带（<code>Looper</code>）开始转动（调用 <code>Looper.loop()</code>）。<br>• 此时传送带是空的，快递站工作人员（主线程）开始等待包裹。</p>
<h4 id="2-上午：快递员送来包裹（发送消息）"><a href="#2-上午：快递员送来包裹（发送消息）" class="headerlink" title="(2) 上午：快递员送来包裹（发送消息）"></a><strong>(2) 上午：快递员送来包裹（发送消息）</strong></h4><p>• 快递员A（<code>Handler1</code>）把一个包裹（<code>Message</code>）放到传送带上（<code>MessageQueue</code>）。</p>
<pre><code class="java">handler1.sendMessage(msg1); // 快递员A放包裹
</code></pre>
<p>• 快递员B（<code>Handler2</code>）也放了一个包裹。</p>
<pre><code class="java">handler2.sendMessage(msg2); // 快递员B放包裹
</code></pre>
<h4 id="3-中午：传送带处理包裹（处理消息）"><a href="#3-中午：传送带处理包裹（处理消息）" class="headerlink" title="(3) 中午：传送带处理包裹（处理消息）"></a><strong>(3) 中午：传送带处理包裹（处理消息）</strong></h4><p>• 传送带（<code>Looper</code>）转动时，发现第一个包裹（<code>msg1</code>），检查包裹上的标签：<br>  • <strong>标签写着：“由快递员A处理”</strong>（<code>msg1.target = handler1</code>）。<br>• 传送带把包裹交给快递员A处理：</p>
<pre><code class="java">handler1.handleMessage(msg1); // 快递员A拆包裹
</code></pre>
<p>• 接着处理第二个包裹（<code>msg2</code>），交给快递员B处理。</p>
<h4 id="4-下午：没有包裹时（线程休眠）"><a href="#4-下午：没有包裹时（线程休眠）" class="headerlink" title="(4) 下午：没有包裹时（线程休眠）"></a><strong>(4) 下午：没有包裹时（线程休眠）</strong></h4><p>• 传送带（<code>Looper</code>）检查发现没有包裹了，暂时停止转动（线程休眠，不消耗 CPU）。<br>• 快递站工作人员（主线程）可以休息，直到有新包裹。</p>
<h4 id="5-傍晚：新包裹到达（唤醒线程）"><a href="#5-傍晚：新包裹到达（唤醒线程）" class="headerlink" title="(5) 傍晚：新包裹到达（唤醒线程）"></a><strong>(5) 傍晚：新包裹到达（唤醒线程）</strong></h4><p>• 快递员C（<code>Handler3</code>）突然送来一个加急包裹。<br>• 传送带被重新启动，继续处理新包裹。</p>
<hr>
<h3 id="3-为什么不会卡死？"><a href="#3-为什么不会卡死？" class="headerlink" title="3. 为什么不会卡死？"></a><strong>3. 为什么不会卡死？</strong></h3><p>• <strong>传送带只在有包裹时工作</strong>：没有包裹时快递站“休眠”，不消耗资源。<br>• <strong>每个包裹独立处理</strong>：处理完一个包裹后，才会处理下一个（保证顺序）。</p>
<hr>
<h3 id="4-快递站的崩溃（ANR-场景）"><a href="#4-快递站的崩溃（ANR-场景）" class="headerlink" title="4. 快递站的崩溃（ANR 场景）"></a><strong>4. 快递站的崩溃（ANR 场景）</strong></h3><p>如果某个包裹里装了一吨重的货物（<strong>主线程执行耗时操作</strong>），比如：</p>
<pre><code class="java">handler1.post(() -&gt; &#123;
    // 模拟处理一个耗时包裹（比如下载文件）
    Thread.sleep(10_000); // 主线程卡住 10 秒！
&#125;);
</code></pre>
<p>• <strong>后果</strong>：传送带被卡住 10 秒，后续所有包裹无法处理，客户投诉（ANR 弹窗）。</p>
<hr>
<h3 id="5-如何避免崩溃？"><a href="#5-如何避免崩溃？" class="headerlink" title="5. 如何避免崩溃？"></a><strong>5. 如何避免崩溃？</strong></h3><p>• <strong>耗时包裹交给分拣中心（子线程）</strong>：</p>
<pre><code class="java">// 快递员发现包裹太重，转交给分拣中心（子线程）
handler1.post(() -&gt; &#123;
    // 主线程：通知分拣中心处理
    new Thread(() -&gt; &#123;
        // 子线程：处理耗时操作（比如下载文件）
        downloadFile();
        // 处理完通知主线程更新
        handler1.post(() -&gt; updateUI());
    &#125;).start();
&#125;);
</code></pre>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>• <strong>Looper &#x3D; 传送带</strong>：让线程持续运转，但只在有任务时工作。<br>• <strong>Handler &#x3D; 快递员</strong>：负责投递任务和处理任务。<br>• <strong>ANR 就是快递站被卡死</strong>：主线程处理耗时任务时，无法处理新任务。</p>

</article>

<div id="paginator">
  
</div>

      </div>
    </div>

  </div>

  <!-- 底部信息 -->
  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Swithun Liu using
      <a target="_blank" rel="noopener" href="http://hexo.io">hexo blog framework</a>.
      <br>
      <a href="/">Home</a>
    </div>
  </div>


  
  <!-- scripts list from theme config.yml -->
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.0-alpha1/highlight.min.js"></script>
  
  <script src="/lib/jquery-3.4.1.min.js"></script>
  
  <script src="/lib/jquery.pjax.js"></script>
  
  <script src="/js/again.js"></script>
  
  <script src="/js/img.js"></script>
  
  


  <!-- 高亮脚本启动 -->
  <script>hljs.initHighlightingOnLoad();</script>

    <!-- 如果设置中mermaid选项打开 -->
    
    <!-- 引入mermaid脚本 -->
    <div class=".pjax-reload">
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.3.0/mermaid.min.js'></script>
    </div>
    <!-- mermaid启动 -->
    <script>
      if (window.mermaid) {
        mermaid.initialize({ theme: 'dark' });
      }
    </script>
    

</body>

</html>