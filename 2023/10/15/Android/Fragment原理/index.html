

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title> [ Swithun Blog ]</title>

  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/lib/font-awesome-4.7.0/css/font-awesome.min.css">
  
  <link rel="stylesheet" href="/lib/highlight-11-9-0/src/styles/atom-one-dark.css">
  
  <link rel="stylesheet" href="/css/again.css">
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>

  <!-- menu -->
  <div id="menu-outer">
    <div id="menu-inner">
      
      <a class="menu-button" href="/">Home</a>
      
      <a class="menu-button" href="/about">About</a>
      
      <a class="menu-button" href="/contact">Contact</a>
      
      <a class="menu-button" href="/archives">Archives</a>
      
      <a class="menu-button" href="/categories">Category</a>
      
    </div>
  </div>

  <!-- 中间主体 -->
  <div id="main">
    <!-- 侧边栏 -->
    <div id="aside-outer">
      <aside>
        <!-- 搜索栏 -->
<div id="search">
    <input class="search-input" type="text" placeholder="search">
    <i id="search-icon" class="fa fa-bars" title="切换目录与索引"></i>
</div>

<!-- 侧边目录栏 -->
<div id="tree">
    

    

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            Android
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/Android/2023-10-10-viewmodel原理/">
                            <i class="fa fa-file"></i>
                            2023-10-10-viewmodel原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file active">
                        <a href="/2023/10/15/Android/Fragment原理/">
                            <i class="fa fa-file"></i>
                            Fragment原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/22/Android/temp/">
                            <i class="fa fa-file"></i>
                            temp
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            demo_folder_level1
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/demo_folder_level1/demo1/">
                            <i class="fa fa-file"></i>
                            demo1
                        </a>
                    </li>
                </ul>

              

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            demo_folder_level2
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/demo_folder_level1/demo_folder_level2/demo2/">
                            <i class="fa fa-file"></i>
                            demo2
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 
</div>

<div id="toc" style="display: none;"></div>
      </aside>
    </div>
    <!-- 文章内容 -->
    <div id="content-outer">
      <div id="content-inner">
        
<article id="post">
  <h1></h1>
  <p>基于Android Api 33</p>
<pre><code class="java">// androidx.fragment.app.FragmentActivity
public class FragmentActivity extends ComponentActivity  ... &#123;

    final FragmentController mFragments = FragmentController.createController(new HostCallbacks());
</code></pre>
<pre><code class="java">// androidx.fragment.app.FragmentController
public class FragmentController &#123;
    private final FragmentHostCallback&lt;?&gt; mHost;
</code></pre>
<pre class="mermaid">classDiagram

class FragmentActivity {
    - FragmentController mFragments
}
class FragmentController {
    - FragmentHostCallback<?> mHost
    - FragmentManager getSupportFragmentManager()
}
class FragmentManager {
    <<abstract>>
    - FragmentStore mFragmentStore
}
class FragmentManagerImpl
class FragmentHostCallback {
    <<abstract>>
    - FragmentManager mFragmentManager
}
class FragmentStore

FragmentActivity --> FragmentController: hold
FragmentController --> FragmentHostCallback: hold
FragmentHostCallback --> FragmentManager: hold
FragmentManagerImpl --|> FragmentManager: implements
FragmentManager --> FragmentStore: hold</pre>

<ul>
<li><p><code>FragmentController</code>&gt; </p>
<ul>
<li>Provides integration points with a FragmentManager for a fragment host.<br>“提供与 FragmentManager 集成的接口，用于托管片段（Fragment）。</li>
<li>It is the responsibility of the host to take care of the Fragment’s lifecycle. The methods provided by FragmentController are for that purpose.<br>宿主（Host）需要负责处理片段（Fragment）的生命周期。FragmentController 提供的方法就是为了这个目的。”</li>
</ul>
</li>
<li><p><code>androidx.fragment.app.FragmentManager</code></p>
<ul>
<li><p>Static library support version of the framework’s android.app.FragmentManager. Used to write apps that run on platforms prior to Android 3.0. When running on Android 3.0 or above, this implementation is still used; it does not try to switch to the framework’s implementation. See the framework FragmentManager documentation for a class overview.</p>
</li>
<li><p>Your activity must derive from FragmentActivity to use this. From such an activity, you can acquire the FragmentManager by calling FragmentActivity.getSupportFragmentManager.</p>
</li>
</ul>
</li>
</ul>
<pre><code class="java">// androidx.fragment.app.Fragment
    static final int INITIALIZING = -1;          // Not yet attached.
    static final int ATTACHED = 0;               // Attached to the host.
    static final int CREATED = 1;                // Created.
    static final int VIEW_CREATED = 2;           // View Created.
    static final int AWAITING_EXIT_EFFECTS = 3;  // Downward state, awaiting exit effects
    static final int ACTIVITY_CREATED = 4;       // Fully created, not started.
    static final int STARTED = 5;                // Created and started, not resumed.
    static final int AWAITING_ENTER_EFFECTS = 6; // Upward state, awaiting enter effects
    static final int RESUMED = 7;                // Created started and resumed.
</code></pre>
<p><img src="/image.png" alt="Fragment Lifecycle"></p>
<h2 id="Activity的生命周期与Fragment生命周期的关联"><a href="#Activity的生命周期与Fragment生命周期的关联" class="headerlink" title="Activity的生命周期与Fragment生命周期的关联"></a>Activity的生命周期与Fragment生命周期的关联</h2><p><img src="/image-2.png" alt="Alt text"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/f1&quot;
        android:text=&quot;Fragment 1&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        /&gt;

    &lt;fragment android:name=&quot;com.example.test_android.Fragment1&quot;
        android:id=&quot;@+id/prefill_fragment&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        app:layout_constraintTop_toBottomOf=&quot;@id/f1&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintBottom_toTopOf=&quot;@id/content_fragment&quot;
        /&gt;

    &lt;FrameLayout
        android:id=&quot;@+id/content_fragment&quot;
        android:background=&quot;#8EFDCB&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        app:layout_constraintTop_toBottomOf=&quot;@id/prefill_fragment&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        /&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>
<pre><code class="kotlin">import android.content.Context
import android.os.Bundle
import android.util.AttributeSet
import android.util.Log
import android.view.View
import android.widget.Button
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity

class MainActivity : FragmentActivity() &#123;

    var f1: Button? = null

    override fun onCreate(savedInstanceState: Bundle?) &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;MainActivity onCreate&quot;)
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        f1 = findViewById(R.id.f1)

        f1()
        Log.d(&quot;swithun-xxxx&quot;, &quot;MainActivity onCreate end&quot;)
    &#125;

    override fun onStart() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;MainActivity onStart begin&quot;)
        super.onStart()
        Log.d(&quot;swithun-xxxx&quot;, &quot;MainActivity onStart end&quot;)
    &#125;

    override fun onCreateView(name: String, context: Context, attrs: AttributeSet): View? &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;MainActivity onCreateView 1&quot;)
        return super.onCreateView(name, context, attrs)
    &#125;

    override fun onCreateView(
        parent: View?,
        name: String,
        context: Context,
        attrs: AttributeSet
    ): View? &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;MainActivity onCreateView 2&quot;)
        return super.onCreateView(parent, name, context, attrs)
    &#125;

    override fun onAttachFragment(fragment: Fragment) &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;MainActivity onAttachFragment&quot;)
        super.onAttachFragment(fragment)
    &#125;

    override fun onResume() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;MainActivity onResume&quot;)
        super.onResume()
    &#125;

    override fun onStop() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;MainActivity onResume&quot;)
        super.onStop()
    &#125;

    override fun onDestroy() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;MainActivity onDestroy&quot;)
        super.onDestroy()
    &#125;

    private fun f1() &#123;
        f1?.setOnClickListener &#123;
            val transaction = supportFragmentManager.beginTransaction();
            transaction.replace(R.id.content_fragment, Fragment2())
            transaction.commit()
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="kotlin">import android.content.Context
import android.os.Bundle
import android.util.Log
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.TextView
import androidx.fragment.app.Fragment

open class Fragment1: Fragment() &#123;

    open val name = &quot;fragment 1&quot;

    override fun onAttach(context: Context) &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onAttach&quot;)
        super.onAttach(context)
    &#125;

    override fun onCreate(savedInstanceState: Bundle?) &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onCreate&quot;)
        super.onCreate(savedInstanceState)
    &#125;

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? &#123;
        // 居中添加一个TextView——“hello Fragment1&quot;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onCreateView&quot;)
        val view = TextView(context)
        val param = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)
        param.gravity = Gravity.CENTER
        view.layoutParams = param
        view.text = &quot;hello $name&quot;
        view.textSize = 15F
        view.gravity = Gravity.CENTER
        return view
    &#125;

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onViewCreated&quot;)
        super.onViewCreated(view, savedInstanceState)
    &#125;

    override fun onActivityCreated(savedInstanceState: Bundle?) &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onActivityCreated&quot;)
        super.onActivityCreated(savedInstanceState)
    &#125;

    override fun onStart() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onStart&quot;)
        super.onStart()
    &#125;

    override fun onResume() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onResume&quot;)
        super.onResume()
    &#125;

    override fun onPause() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onPause&quot;)
        super.onPause()
    &#125;

    override fun onStop() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onStop&quot;)
        super.onStop()
    &#125;

    override fun onDestroyView() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onDestroyView&quot;)
        super.onDestroyView()
    &#125;

    override fun onDestroy() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onDestroy&quot;)
        super.onDestroy()
    &#125;

    override fun onDetach() &#123;
        Log.d(&quot;swithun-xxxx&quot;, &quot;$name onDetach&quot;)
        super.onDetach()
    &#125;
&#125;
</code></pre>
<pre><code class="kotlin">class Fragment2: Fragment1() &#123;
    override val name: String = &quot;Fragment 2&quot;
&#125;
</code></pre>
<h3 id="通过xml文件添加Fragment-——-Fragment1"><a href="#通过xml文件添加Fragment-——-Fragment1" class="headerlink" title="通过xml文件添加Fragment —— Fragment1"></a>通过xml文件添加Fragment —— Fragment1</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    ...

    &lt;fragment android:name=&quot;com.example.test_android.Fragment1&quot;
        android:id=&quot;@+id/prefill_fragment&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        app:layout_constraintTop_toBottomOf=&quot;@id/f1&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintBottom_toTopOf=&quot;@id/content_fragment&quot;
        /&gt;
    ...

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>
<p>先从代码分析，从<code>FragmentActivity</code>.<code>onCreate</code> 开始看</p>
<ul>
<li><p><code>[T-1] MainActivity.onCreate</code></p>
<pre><code class="kotlin">    // MainActivity
class MainActivity : FragmentActivity() &#123;
    ...
    override fun onCreate(savedInstanceState: Bundle?) &#123;
   [:0] super.onCreate(savedInstanceState)
   [:1] setContentView(R.layout.activity_main)
</code></pre>
</li>
<li><p><code>[:0] FragmentActivity.onCreate</code></p>
<pre><code class="java">// androidx.fragment.app.FragmentActivity
    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;
        ...
    [:0:1] mFragments.dispatchCreate();
    &#125;
</code></pre>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate</pre>

  <pre class="mermaid">    classDiagram

  class FragmentActivity {
      - FragmentController mFragments
  }
  class FragmentController

  FragmentActivity --> FragmentController: hold</pre>

<p>  可以看出  </p>
<ol>
<li><code>FragmentActivity</code>持有<code>FragmentController</code></li>
<li>通知<code>FragmentController</code>分发<code>create</code>事件</li>
</ol>
</li>
<li><p><code>[:0:1] mFragments.dispatchCreate()</code></p>
<pre><code class="java">// androidx.fragment.app.FragmentController
    public void dispatchCreate() &#123;
   [:0:1:0] mHost.mFragmentManager.dispatchCreate();
    &#125;
</code></pre>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate
  FragmentController->>FragmentManager: dispatchCreate</pre>

  <pre class="mermaid">    classDiagram

  class FragmentActivity {
      - FragmentController mFragments
  }
  class FragmentController {
      - FragmentHostCallback<?> mHost
  }
  class FragmentManager {
      <<abstract>>
  }
  class FragmentManagerImpl
  class FragmentHostCallback {
      <<abstract>>
      - FragmentManager mFragmentManager
  }

  FragmentActivity --> FragmentController: hold
  FragmentController --> FragmentHostCallback: hold
  FragmentHostCallback --> FragmentManager: hold
  FragmentManagerImpl --|> FragmentManager: implements</pre>
<p>  可以看出</p>
<ol>
<li><code>FragmentController</code>持有<code>FragmentHostCallback</code>持有<code>FragmentManger</code></li>
<li>通知<code>FragmentManager</code>分发<code>create</code>事件</li>
</ol>
</li>
<li><p><code>[:0:1:0] mHost.mFragmentManager.dispatchCreate()</code></p>
<pre><code class="java">// androidx.fragment.app.FragmentManager
    void dispatchCreate() &#123;
        ...
   [:0:1:0:0] dispatchStateChange(Fragment.CREATED);
        ...
    &#125;
</code></pre>
<pre><code class="java">public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner,
        ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner,
        ActivityResultCaller &#123;

    static final int INITIALIZING = -1;          // Not yet attached.
    static final int ATTACHED = 0;               // Attached to the host.
    static final int CREATED = 1;                // Created.
    static final int VIEW_CREATED = 2;           // View Created.
    static final int AWAITING_EXIT_EFFECTS = 3;  // Downward state, awaiting exit effects
    static final int ACTIVITY_CREATED = 4;       // Fully created, not started.
    static final int STARTED = 5;                // Created and started, not resumed.
    static final int AWAITING_ENTER_EFFECTS = 6; // Upward state, awaiting enter effects
    static final int RESUMED = 7;                // Created started and resumed.
</code></pre>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController
  participant FragmentManager

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate
  FragmentController->>FragmentManager: dispatchCreate
  FragmentManager->>FragmentManager: dispatchStateChange</pre>
<p>  可以看出</p>
<ol>
<li><code>FragmentManager</code>内部分发<code>Fragment.CREATED</code>事件——<em>Attached to the host</em></li>
</ol>
</li>
<li><p><code>[:0:1:0:0] dispatchStateChange(Fragment.CREATED)</code></p>
<pre><code class="java">// androidx.fragment.app.FragmentManager
    private void dispatchStateChange(int nextState) &#123;
        ...
       [:0:1:0:0:0] mFragmentStore.dispatchStateChange(nextState);
       [:0:1:0:0:1] moveToState(nextState, false);
       ...
&#125;
</code></pre>
<pre><code class="java">public abstract class FragmentManager implements FragmentResultOwner &#123;
    ...
    private final FragmentStore mFragmentStore = new FragmentStore();
</code></pre>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController
  participant FragmentManager
  participant FragmentStore

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate
  FragmentController->>FragmentManager: dispatchCreate
  FragmentManager->>FragmentManager: dispatchStateChange
  FragmentManager->>FragmentStore: dispatchStateChange</pre>

  <pre class="mermaid">    classDiagram

  class FragmentActivity {
      - FragmentController mFragments
  }
  class FragmentController {
      - FragmentHostCallback<?> mHost
  }
  class FragmentManager {
      <<abstract>>
      FragmentStore mFragmentStore
  }
  class FragmentManagerImpl
  class FragmentHostCallback {
      <<abstract>>
      - FragmentManager mFragmentManager
  }
  class FragmentStore

  FragmentActivity --> FragmentController: hold
  FragmentController --> FragmentHostCallback: hold
  FragmentHostCallback --> FragmentManager: hold
  FragmentManagerImpl --|> FragmentManager: implements
  FragmentManager --> FragmentStore: hold</pre>
<p>  可以看出</p>
<ol>
<li><code>FragmentManager</code>持有一个<code>FragmentStore</code></li>
<li><code>FragmentStore</code>分发收到的状态<code>nextState</code>——<code>Fragment.CREATED</code></li>
</ol>
</li>
<li><p><code>[:0:1:0:0:0] mFragmentStore.dispatchStateChange(nextState)</code></p>
<pre><code class="java">// androidx.fragment.app.FragmentStore
    void dispatchStateChange(int state) &#123;
        for (FragmentStateManager fragmentStateManager : mActive.values()) &#123;
            if (fragmentStateManager != null) &#123;
 [:0:1:0:0:0:0] fragmentStateManager.setFragmentManagerState(state);
            &#125;
        &#125;
    &#125;
</code></pre>
<p>  <code>mActive</code>是存储<code>FragmentStateManager</code>的<code>Map</code>:⬇️</p>
<pre><code class="java">// androidx.fragment.app.FragmentStore
class FragmentStore &#123;
    ...
    private final HashMap&lt;String, FragmentStateManager&gt; mActive = new HashMap&lt;&gt;();
</code></pre>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController
  participant FragmentManager
  participant FragmentStore
  participant FragmentStateManager

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate
  FragmentController->>FragmentManager: dispatchCreate
  FragmentManager->>FragmentManager: dispatchStateChange
  FragmentManager->>FragmentStore: dispatchStateChange
  FragmentStore->>FragmentStateManager: setFragmentManagerState</pre>

  <pre class="mermaid">    classDiagram

  class FragmentActivity {
      - FragmentController mFragments
  }
  class FragmentController {
      - FragmentHostCallback<?> mHost
  }
  class FragmentManager {
      <<abstract>>
      FragmentStore mFragmentStore
  }
  class FragmentManagerImpl
  class FragmentHostCallback {
      <<abstract>>
      - FragmentManager mFragmentManager
  }
  class FragmentStore {
      HashMap「String, FragmentStateManager」 mActive
  }
  class FragmentStateManager

  FragmentActivity --> FragmentController: hold
  FragmentController --> FragmentHostCallback: hold
  FragmentHostCallback --> FragmentManager: hold
  FragmentManagerImpl --|> FragmentManager: implements
  FragmentManager --> FragmentStore: hold
  FragmentStore "1" --> "n" FragmentStateManager: hold</pre>
<p>  可以看出</p>
<ol>
<li><code>FragmentStore</code>持有n个<code>FragmentStateManager</code></li>
<li><code>FragmentManager</code>将收到的状态分发给每一个<code>FragmentStateManager</code></li>
</ol>
<p>  <strong>[总结]</strong>: 由于<code>FragmentActivity</code>此时尚未<code>setContentView</code>，所以<code>FragmentManger</code>管理的<code>Fragment</code>数量实际上为0，<code>mActive</code>自然为0。但是我们仍然继续看下如果不为0会继续做什么。</p>
</li>
<li><p><code>[:0:1:0:0:0:0] fragmentStateManager.setFragmentManagerState(state)</code></p>
<pre><code class="java">// androidx.fragment.app.FragmentStateManager
    void setFragmentManagerState(int state) &#123;
        mFragmentManagerState = state;
    &#125;
</code></pre>
<pre><code class="java">// androidx.fragment.app.FragmentStateManager
class FragmentStateManager &#123;
    ...
    private final Fragment mFragment;
    private int mFragmentManagerState = Fragment.INITIALIZING;
</code></pre>
  <pre class="mermaid">    classDiagram

  class FragmentActivity {
      - FragmentController mFragments
  }
  class FragmentController {
      - FragmentHostCallback<?> mHost
  }
  class FragmentManager {
      <<abstract>>
      FragmentStore mFragmentStore
  }
  class FragmentManagerImpl
  class FragmentHostCallback {
      <<abstract>>
      - FragmentManager mFragmentManager
  }
  class FragmentStore {
      HashMap「String, FragmentStateManager」 mActive
  }
  class FragmentStateManager {
      Fragment mFragment
      int mFragmentManagerState
  }
  class Fragment

  FragmentActivity --> FragmentController: hold
  FragmentController --> FragmentHostCallback: hold
  FragmentHostCallback --> FragmentManager: hold
  FragmentManagerImpl --|> FragmentManager: implements
  FragmentManager --> FragmentStore: hold
  FragmentStore "1" --> "n" FragmentStateManager: hold
  FragmentStateManager --> Fragment: hold</pre>
<p>  可以看出</p>
<ol>
<li><code>FragmentStateManager</code> 1:1 持有<code>Fragment</code></li>
<li><code>FragmentStateManaget</code>持有变量<code>mFragmentManagerState</code>——所属的FragmentManager的状态</li>
</ol>
<p>  至此，<code>FragmentActivity</code>将<code>CREATE</code>状态通知到<code>FragmentManager</code>进而通知到管理的每个<code>FragmentStateManager</code>——但是此时Fragment尚未更新。</p>
<p>  <strong>[总结]</strong>: （只关心重要的<code>FragmentActivity</code>,<code>FragmentManager</code>,<code>Fragment</code>）  </p>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentManager
  participant Fragment
  
  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentManager: dispatchCreate() 分发CREATE</pre>
</li>
<li><p><code>[:0:1:0:0:1] moveToState(nextState, false);</code></p>
<pre><code class="java">// androidx.fragment.app.FragmentManager
    void moveToState(int newState, boolean always) &#123;
        ...
            mFragmentStore.moveToExpectedState();
        ...
</code></pre>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController
  participant FragmentManager
  participant FragmentStore

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate
  FragmentController->>FragmentManager: dispatchCreate
  FragmentManager->>FragmentManager: dispatchStateChange
  FragmentManager->>FragmentStore: dispatchStateChange
  FragmentManager->>FragmentManager: moveToState</pre>

<p>  <code>[:0:1:0:0:0:0]</code>只是将用来管理<code>Fragment</code>的<code>FragmentStateManager</code>的状态更新了，这里才是真正更新<code>Fragment</code>的状态——但是此时<code>FragmentManager</code>管理的<code>Fragment</code>数量实际上为0，所以这里先不继续看，后续流程下面<code>[:1:0:0:1]</code>会继续讲到。</p>
</li>
<li><p><code>[:1] setContentView(R.layout.activity_main)</code><br>  执行<code>[:0] super.onCreate(savedInstanceState)</code>之后，setContentView</p>
<pre><code class="java">// androidx.activity.ComponentActivity
    @Override
    public void setContentView(@LayoutRes int layoutResID) &#123;
        ...
    [:1:0] super.setContentView(layoutResID);
    &#125;
</code></pre>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController
  participant Activity

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate
  FragmentActivity->>Activity: setContentView</pre>

  <pre class="mermaid">    classDiagram

  class FragmentActivity {
      - FragmentController mFragments
  }
  class FragmentController
  class Activity

  FragmentActivity --> FragmentController: hold
  FragmentActivity --|> Activity</pre>
</li>
<li><p><code>[:1:0] super.setContentView(layoutResID);</code><br>  <code>ComponentActivity</code>调用父类<code>Activity</code>.<code>setContentView</code></p>
<pre><code class="java">// android.app.Activity
    public void setContentView(@LayoutRes int layoutResID) &#123;
   [:1:0:0] getWindow().setContentView(layoutResID);
   ...
</code></pre>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController
  participant Activity
  participant Window

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate
  FragmentActivity->>Activity: setContentView
  Activity->>Window: setContentView</pre>

  <pre class="mermaid">    classDiagram

  class FragmentActivity {
      - FragmentController mFragments
  }
  class FragmentController
  class Activity {
      - Window mWindow
  }

  FragmentActivity --> FragmentController: hold
  FragmentActivity --|> Activity
  Activity --> Window: hold</pre>
</li>
<li><p><code>[:1:0:0] getWindow().setContentView(layoutResID);</code><br>  <code>Window</code>.<code>setContentView</code></p>
<pre><code class="java">// android.view.Window
    public abstract void setContentView(@LayoutRes int layoutResID);
</code></pre>
<p>  继续-跳过细节 根据传入的layout ResId 初始化 view</p>
<pre><code class="java">// com.android.internal.policy.PhoneWindow
    @Override
    public void setContentView(int layoutResID) &#123;
        ...
        [...]    mLayoutInflater.inflate(layoutResID, mContentParent);
        ...
</code></pre>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController
  participant Activity
  participant PhoneWindow
  participant LayoutInflater

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate
  FragmentActivity->>Activity: setContentView
  Activity->>PhoneWindow: setContentView
  PhoneWindow->>LayoutInflater: inflate</pre>

  <pre class="mermaid">    classDiagram

  class FragmentActivity {
      - FragmentController mFragments
  }
  class FragmentController
  class Activity {
      - Window mWindow
  }
  class PhoneWindow {
      - LayoutInflater mLayoutInflater
  }
  class LayoutInflater

  FragmentActivity --> FragmentController: hold
  FragmentActivity --|> Activity
  Activity --> Window: hold
  PhoneWindow --|> Window
  PhoneWindow --> LayoutInflater: hold</pre>

<p>  <code>mContentParent</code>为<code>PhoneWindow</code>的根View，下面会根据<code>layoutResID</code>构造<code>View</code>并add到<code>mContentParent</code><br>  继续-跳过细节 根据传入的layout ResId 初始化 view</p>
<pre><code class="java">// android.view.LayoutInflater
    public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;
        return inflate(resource, root, root != null);
</code></pre>
<pre><code class="java">// android.view.LayoutInflater
    public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;
        [...] return inflate(parser, root, attachToRoot);
        ...
    &#125;
</code></pre>
<p>  <code>attachToRoot</code>为true(<code>root != null</code>)  </p>
<pre><code class="java">    // android.view.LayoutInflater
    public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;
        synchronized (mConstructorArgs) &#123;
            ...
                advanceToRootNode(parser); // 让parser移动到下一个要解析的&quot;结点&quot;
                final String name = parser.getName(); // 获取结点名字
                ...
                    // 根据名字构造xml的根view
                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);
                ...
                    // 继续递归构造xml根view的子view，并addView到根view
                    rInflateChildren(parser, temp, attrs, true);
</code></pre>
<p>  根据<code>xml parser</code>构造<code>View</code>，<code>temp</code>是<code>xml</code>的根标签代表的view，根据<code>activity_main.xml</code><br>  <code>xml-1</code> ⬇️</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout     ...&gt;
    &lt;Button..&gt;

    &lt;fragment android:name=&quot;com.example.test_android.Fragment1&quot;...&gt;

    &lt;FrameLayout
        android:id=&quot;@+id/content_fragment&quot;...&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>
<p>  <code>name</code>则为根标签<code>androidx.constraintlayout.widget.ConstraintLayout</code>，<br>  <code>temp</code>相应的则是<code>androidx.constraintlayout.widget.ConstraintLayout</code>，<br>  下面<code>rInflateChildren</code>则是继续递归的构造<code>ConstraintLayout</code>中的子view。(开头的<code>r</code>代表的是<em>Recursive</em>–<em>递归</em>)</p>
<pre><code class="java">// android.view.LayoutInflater
    final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,
            boolean finishInflate) throws XmlPullParserException, IOException &#123;
        rInflate(parser, parent, parent.getContext(), attrs, finishInflate);
</code></pre>
<pre><code class="java">// android.view.LayoutInflater
    void rInflate(XmlPullParser parser, View parent, Context context,
            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;
        ...
            while (((type = parser.next()) != XmlPullParser.END_TAG ||
                ...
                final View view = createViewFromTag(parent, name, context, attrs);
        ...
</code></pre>
<p>  <code>rInflate</code>: 继续递归构造<code>temp</code>的子view<br>  <code>parser.next</code>: 不断的获取下一个要解析的标签，根据<code>xml-1</code>，会解析到 <code>&lt;fragment</code>标签——通过<code>createViewFromTag</code>构造Fragment</p>
<pre><code class="java">// android.view.LayoutInflater
    private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123;
        return createViewFromTag(parent, name, context, attrs, false);
</code></pre>
<pre><code class="java">// android.view.LayoutInflater
    View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,
        ...
            View view = tryCreateView(parent, name, context, attrs);
        ...
</code></pre>
<p>  构造fragment view</p>
<pre><code class="java">// android.view.LayoutInflater
    public final View tryCreateView(@Nullable View parent, @NonNull String name,
        ...
            view = mPrivateFactory.onCreateView(parent, name, context, attrs);
        ...
</code></pre>
<pre><code class="java">// android.view.LayoutInflater
    private Factory2 mPrivateFactory;
</code></pre>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController
  participant Activity
  participant PhoneWindow
  participant LayoutInflater
  participant LayoutInflater-Factory2

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate
  FragmentActivity->>Activity: setContentView
  Activity->>PhoneWindow: setContentView
  PhoneWindow->>LayoutInflater: inflate
  LayoutInflater->>LayoutInflater-Factory2: onCreateView</pre>

  <pre class="mermaid">    classDiagram

  class FragmentActivity {
      - FragmentController mFragments
  }
  class FragmentController
  class Activity {
      - Window mWindow
  }
  class PhoneWindow {
      - LayoutInflater mLayoutInflater
  }
  class LayoutInflater
  class LayoutInflater-Factory2

  FragmentActivity --> FragmentController: hold
  FragmentActivity --|> Activity
  Activity --> Window: hold
  PhoneWindow --|> Window
  PhoneWindow --> LayoutInflater: hold
  Activity --|> LayoutInflater-Factory2
  LayoutInflater --> LayoutInflater-Factory2: hold</pre>


<p>  <code>mPrivateFactory</code>实际上是我们写的的<code>MainActivity</code>，所以继续会走到<code>MainActivity.onCreateView</code></p>
<pre><code class="java">// androidx.fragment.app.FragmentActivity
    public View onCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context,
            @NonNull AttributeSet attrs) &#123;
        final View v = dispatchFragmentsOnCreateView(parent, name, context, attrs);
        if (v == null) &#123;
            return super.onCreateView(parent, name, context, attrs);
        &#125;
        return v;
    &#125;
</code></pre>
<p>  <code>@param View parent</code>: xml的根布局<code>ConstraintLayout</code><br>  <code>@param String name</code>: <code>fragment</code>，也就是<code>xml-1</code>中的<code>fragment</code>标签<br>  <code>dispatchFragmentsOnCreateView(</code>: 会先尝试通过该方法处理<code>fragment</code>标签对应的View，如果有返回结果则跳过<code>if (v == null)</code>中的逻辑，我们这里<code>name</code>为<code>framgment</code>，所以不应该返回null。</p>
  <pre class="mermaid">    sequenceDiagram
  autonumber

  participant FragmentActivity
  participant FragmentController
  participant Activity
  participant PhoneWindow
  participant LayoutInflater
  participant LayoutInflater-Factory2

  FragmentActivity->>FragmentActivity: onCreate begin
  FragmentActivity->>FragmentController: dispatchCreate
  FragmentActivity->>Activity: setContentView
  Activity->>PhoneWindow: setContentView
  PhoneWindow->>LayoutInflater: inflate
  LayoutInflater->>LayoutInflater-Factory2: onCreateView
  LayoutInflater-Factory2->>FragmentActivity: onCreateView</pre>

  <pre class="mermaid">    classDiagram

  class FragmentActivity {
      - FragmentController mFragments
  }
  class FragmentController
  class Activity {
      - Window mWindow
  }
  class PhoneWindow {
      - LayoutInflater mLayoutInflater
  }
  class LayoutInflater
  class LayoutInflater-Factory2

  FragmentActivity --> FragmentController: hold
  FragmentActivity --|> Activity
  Activity --> Window: hold
  PhoneWindow --|> Window
  PhoneWindow --> LayoutInflater: hold
  Activity --|> LayoutInflater-Factory2
  LayoutInflater --> LayoutInflater-Factory2: hold</pre>

<pre><code class="java">// androidx.fragment.app.FragmentActivity
    @Nullable
    final View dispatchFragmentsOnCreateView(@Nullable View parent, @NonNull String name,
            @NonNull Context context, @NonNull AttributeSet attrs) &#123;
        return mFragments.onCreateView(parent, name, context, attrs);
</code></pre>
<pre><code class="java">// androidx.fragment.app.FragmentController
    public View onCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context,
            @NonNull AttributeSet attrs) &#123;
        return mHost.mFragmentManager.getLayoutInflaterFactory()
                .onCreateView(parent, name, context, attrs);
    &#125;
</code></pre>
<p>  return <code>FragmentActivity.dispatchFragmentsOnCreateView</code> $\rightarrow$ return <code>FragmentController.onCreateView</code> $\rightarrow$ return <code>FragmentLayoutInflaterFactory.onCreateView</code></p>
<pre><code class="java">// androidx.fragment.app.FragmentLayoutInflaterFactory
    public View onCreateView(@Nullable final View parent, @NonNull String name,
        ...
            // new Fragment
            fragment = mFragmentManager.getFragmentFactory().instantiate(
            context.getClassLoader(), fname);
            // fragment 的属性设置 begin
            fragment.mFromLayout = true;
            fragment.mFragmentId = id != 0 ? id : containerId;
            fragment.mContainerId = containerId;
            fragment.mTag = tag;
            fragment.mInLayout = true;
            fragment.mFragmentManager = mFragmentManager;
            fragment.mHost = mFragmentManager.getHost();
            fragment.onInflate(mFragmentManager.getHost().getContext(), attrs,
                    fragment.mSavedFragmentState);
            // fragment 的属性设置 end

            // 添加到mFragmentManager中，同时返回 持有Fragment的FragmentStateManager
            fragmentStateManager = mFragmentManager.addFragment(fragment);
            // 此时Fragment这个壳已经初始化，但是Fragment.mView实际上还没有构造
        ...
        // 通过FragmentStateManager更新他持有的一对一的Fragment的State
   [:1:0:0:1] fragmentStateManager.moveToExpectedState();
        // 确保走到这行代码是Fragment已经构造好view
   [B2] fragmentStateManager.ensureInflatedView();
</code></pre>
<ul>
<li><code>fragmentStateManager = mFragmentManager.addFragment(fragment);</code>: 将新建的<code>Fragment</code>添加到<code>FragmentManager</code>中进行管理。</li>
</ul>
</li>
<li><p><code>[:1:0:0:1] fragmentStateManager.moveToExpectedState();</code><br>  通过FragmentStateManager更新他持有的一对一的Fragment的State  </p>
<pre><code class="java">// androidx.fragment.app.FragmentStateManager
    void moveToExpectedState() &#123;
        ...
            int newState;
     [:1:0:0:1:0] while ((newState = computeExpectedState()) != mFragment.mState) &#123;
                if (newState &gt; mFragment.mState) &#123;
                    // Moving upward
                    int nextStep = mFragment.mState + 1;
                    switch (nextStep) &#123;
                        case Fragment.ATTACHED:
                     [:1:0:0:1:1] attach();
                        case Fragment.CREATED:
                     [:1:0:0:1:2] create();
                            break;
                        case Fragment.VIEW_CREATED:
                     [:1:0:0:1:3] ensureInflatedView();
                     [:1:0:0:1:4] createView();
                            break;
</code></pre>
</li>
<li><p><code>[:1:0:0:1:0] while ((newState = computeExpectedState()) != mFragment.mState) &#123;</code></p>
<ul>
<li><code>computeExpectedState()</code>: 根据FragmentManager等等计算mFragment应该达到的状态，先不看这里的复杂计算，但是最终的结果是2，对应<code>Fragment.VIEW_CREATED</code>，即Fragment应该进行到构造好View的状态</li>
<li><code>while</code>: <code>mFragment</code>不断切换到下一个状态，知道达到目标状态——<code>VIEW_CREATED</code></li>
<li><code>mFragment.mState</code>: 当前<code>mFragment.mState</code>为<code>INITIALIZING</code>，则表示会依次执行<code>FragmentManager.attach()</code>、<code>FragmentManager.create()</code>、<code>FragmentManager.createView()</code></li>
</ul>
<pre><code class="java">    static final int INITIALIZING = -1;          // Not yet attached.
    static final int ATTACHED = 0;               // Attached to the host.
    static final int CREATED = 1;                // Created.
    static final int VIEW_CREATED = 2;           // View Created.
    static final int AWAITING_EXIT_EFFECTS = 3;  // Downward state, awaiting exit effects
    static final int ACTIVITY_CREATED = 4;       // Fully created, not started.
    static final int STARTED = 5;                // Created and started, not resumed.
    static final int AWAITING_ENTER_EFFECTS = 6; // Upward state, awaiting enter effects
    static final int RESUMED = 7;                // Created started and resumed.
</code></pre>
</li>
<li><p><code>[:1:0:0:1:1] attach();</code></p>
<pre><code class="java">// androidx.fragment.app.FragmentStateManager
    void attach() &#123;
        ....
 [:1:0:0:1:1:0] mFragment.performAttach();
        mDispatcher.dispatchOnFragmentAttached(mFragment, false);
    &#125;
</code></pre>
</li>
<li><p><code>[:1:0:0:1:1:0] mFragment.performAttach()</code></p>
<pre><code class="java">// androidx.fragment.app.Fragment
    void performAttach() &#123;
        ...
        mState = ATTACHED;
        onAttach(mHost.getContext());
        ...
        mChildFragmentManager.dispatchAttach();
    &#125;
</code></pre>
<ul>
<li><code>mState = ATTACHED</code>: 更新<code>Fragment</code>状态为<code>ATTACHED</code></li>
</ul>
<pre><code class="java">// androidx.fragment.app.Fragment
    public void onAttach(@NonNull Context context) &#123;
        mCalled = true;
        final Activity hostActivity = mHost == null ? null : mHost.getActivity();
        if (hostActivity != null) &#123;
            mCalled = false;
            onAttach(hostActivity);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">// androidx.fragment.app.Fragment
    public void onAttach(@NonNull Activity activity) &#123;
        mCalled = true;
    &#125;
</code></pre>
</li>
</ul>
<p><strong>至此，<code>Fragment</code>的状态由<code>INITIALIZING</code>切换到<code>ATTACHED</code>切换到<code>CREATED</code>切换到<code>VIEW_CREATED</code>，关键方法是<code>B1</code>-<code>fragmentStateManager.moveToExpectedState</code>，不断的将<code>FragmentStateManager</code>所管理的所有<code>Fragment</code>推动到应该达到的状态。</strong></p>
<pre class="mermaid">sequenceDiagram
autonumber

participant FragmentActivity
participant FragmentManager
participant Fragment

activate FragmentActivity
FragmentActivity->>FragmentActivity: onCreate begin
FragmentActivity->>FragmentManager: dispatchCreate() 分发CREATE
FragmentActivity->>FragmentActivity: setContentView begin
FragmentActivity->>FragmentActivity: onCreateView
FragmentActivity->>FragmentManager: moveToExpectedState
FragmentManager->>Fragment: performAttach
Fragment->>Fragment: onAttach
FragmentManager->>Fragment: performCreate
FragmentManager->>Fragment: performCreateView

FragmentActivity->>FragmentActivity: onCreate end 
deactivate FragmentActivity

FragmentActivity->>FragmentActivity: onStart</pre>

<p>以上以<code>Create</code>为例，了解了<code>FragmentActivity</code>的状态对<code>Fragment</code>的状态影响以及<code>FragmentActivity</code>, <code>FragmentController</code>, <code>FragmentManager</code>, <code>FragmentStateManager</code>, <code>Fragment</code>中间的关系。</p>
<pre><code>MainActivity onCreate
MainActivity onCreateView 2
MainActivity onCreateView 1
MainActivity onCreateView 2
MainActivity onCreateView 1
MainActivity onCreateView 2
MainActivity onCreateView 1
MainActivity onCreateView 2
MainActivity onCreateView 1
MainActivity onCreateView 2
MainActivity onCreateView 1
MainActivity onCreateView 2
fragment 1 onAttach
MainActivity onAttachFragment
fragment 1 onCreate
fragment 1 onCreateView
fragment 1 onViewCreated
MainActivity onCreateView 2
MainActivity onCreateView 1
MainActivity onCreate end
MainActivity onStart begin
fragment 1 onActivityCreated
fragment 1 onStart
MainActivity onStart end
MainActivity onResume
fragment 1 onResumek
</code></pre>
<p>简单总结：</p>
<table>
<thead>
<tr>
<th>Activity 生命周期</th>
<th>Fragment 生命周期回调</th>
</tr>
</thead>
<tbody><tr>
<td>onCreate</td>
<td>- onAttach <br> - onCreate <br> - onCreateView <br> - onViewCreated</td>
</tr>
<tr>
<td>onStart</td>
<td>- onActivityCreated <br> - onStart</td>
</tr>
<tr>
<td>onResume</td>
<td>- onResume</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结以上，<code>FragmentActivity</code> <code>onCreate</code> 时将 <code>Create</code> 事件 $\xrightarrow{1:通知:1}$ <code>FragmentController</code> $\xrightarrow{1:通知:1}$ <code>FragmentManager</code> $\xrightarrow{1:通知:n}$ 持有的每个 <code>FragmentStateManager</code> $\xrightarrow{1:通知:1}$ <code>Fragment</code>。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6970998913754988552">Android Jetpack 开发套件 #7 AndroidX Fragment 核心原理分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.51cto.com/article/672135.html">详细聊聊Fragment的实现原理</a></li>
</ul>

</article>

<script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<div id="paginator">
  
</div>

      </div>
    </div>

  </div>

  <!-- 底部信息 -->
  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Swithun Liu using
      <a target="_blank" rel="noopener" href="http://hexo.io">hexo blog framework</a>.
      <br>
      <a href="/">Home</a>
    </div>
  </div>


  
  <!-- scripts list from theme config.yml -->
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.0-alpha1/highlight.min.js"></script>
  
  <script src="/lib/jquery-3.4.1.min.js"></script>
  
  <script src="/lib/jquery.pjax.js"></script>
  
  <script src="/js/again.js"></script>
  
  


  <!-- 高亮脚本启动 -->
  <script>hljs.initHighlightingOnLoad();</script>

    <!-- 如果设置中mermaid选项打开 -->
    
    <!-- 引入mermaid脚本 -->
    <div class=".pjax-reload">
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.0.0-alpha.4/mermaid.min.js'></script>
    </div>
    <!-- mermaid启动 -->
    <script>
      if (window.mermaid) {
        mermaid.initialize({ theme: 'dark' });
      }
    </script>
    

</body>

</html>