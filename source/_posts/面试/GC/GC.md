## G1之前

1. 根据内存地址划分 E,S,S,O
2. 根据内存地址判断是老年代还是新生代，当老年代引用新生的时候，在cardtable中记录该老年代为脏
3. minor gc阶段：当Eden满了，将Stack、Static、JNI、被标记为脏的老年代作为GCRoots，递归遍历（Eden和上次使用的S）哪些新生代是存活的，当递归到老年代的时候则停止，最后将存活的新生代移动到另一个S中，循环往复交换使用S，每次新生代移动年龄加一，当15岁则变成老年代
4. full gc阶段：当老年代满了，需要将Stack、Static、JNI作为GCRoots、全量递归到底，确认所有存活的对象，确认后有两种清理方式可选（1. 保留存活的在原地 2. 将存活的从头排列整齐，减少内存碎片）

```
+-----------------------------------+
|   App 进程的总内存                |
|                                   |
|  +-----------------------------+  |
|  |     Java 堆 (Heap)          |  |  <-- "1 号仓库" (产品)
|  | [ E | S0 | S1 | Old ]      |  |
|  +-----------------------------+  |
|                                   |
|  +-----------------------------+  |
|  |     虚拟机栈 (Stacks)       |  |  <-- "工人"的"随身工具"
|  +-----------------------------+  |
|                                   |
|  +-----------------------------+  |
|  |     元空间 (Metaspace)      |  |  <-- "2 号仓库" (类的图纸)
|  +-----------------------------+  |
|                                   |
|  +-----------------------------+  |
|  |   JVM/ART 内部内存           |  |  <-- "经理办公室"
|  |   +-------------------+     |  |
|  |   |  JIT 编译代码     |     |  |
|  |   +-------------------+     |  |
|  |   |   卡片表 (Card Table) | <------ 在这里！
|  |   +-------------------+     |  |
|  |   |   RSet (G1 的账本)  |     |  |
|  |   |   GC 状态信息      |     |  |
|  |   +-------------------+     |  |
|  +-----------------------------+  |
|                                   |
+-----------------------------------+
```

## G1

目标：Full GC -> 大型 Stop-The-World! 将1次长卡顿->N次小卡顿

1. “堆” = 一大堆 Region 的集合。`[O][E][S][E][O][O][H][E][S][O][O][E]...`,非常灵活地“动态调整”新生代和老年代的大小。
2. 这是 G1 的“终极版”作弊卡，取代了【G1之前】的 Card Table。

> 有多少个？ (How many?) G1 为 每一个 Region 都配了一个 RSet 账本。 (比如堆被分成 2048 个 Region，就有 2048 个 RSet 账本)。

> 是什么维度的？ (What dimension?) 它是一个“谁指向我” (Who-Points-To-Me) 的列表。 Region 8 的 RSet 账本，记录了所有“外部” Region 指向“Region 8”的引用。 (比如 RSet(Region 8) = { Region 1(Old) 指向我, Region 5(Young) 指向我 })

> G1 如何使用它？ (How?) G1 一直（通过“写屏障”）在维护这个“终极账本”（包括 Old->Old）。 只不过，在“不同”的 GC 模式下，G1 会“按需”去查询 RSet 的“不同”部分。

## minor GC

> 仅仅是“打扫新生代”。它（为了快）不想管老年代的死活

1. 打扫目标 (CSet): [所有 Young Region (E+S)]
2. GCRoots (起点):
   - Stack, Static, JNI (真的 GCRoots)
   - RSet (按需查询) (假的 GCRoots)
        > RSet (按需查询) 详解:
        > G1 会查询所有 [Young Region] 的 RSet 账本。
        > 它在账本里只查找来自 [Old Region] 的引用。
        > 最终得到一个列表：所有 Old -> Young 的引用。
3. 扫描规则：遇老就停
4. 整理方式
    |整理方式|1|2|3|4|5|6|7|8|9|
    |-|-|-|-|-|-|-|-|-|-|
    |minorGC前|O|E|E|S|O|O|空|空|空
    |minorGC后|0|空|空|空|O|O|S(整齐)|空|空|
    |minorGC后-假设不整理|O|E(碎片)|E(碎片)|S(碎片)|O|O|空|空|空|

## mixed GC

1. 触发时机：堆占用率达到阈值，启动阶段一
2. 阶段1-Initial Mark(初始标记)：
   1. GCRoots: Stack&Static&JNI
   2. 深度：向下找一层，存活的(Young/Old)=>"Marking Queue"
3. 阶段2-Concurrent Marking (并发标记)
   1. MarkingQueue: AB
   2. 取出A，A->C, A->D
   3. MarkingQueue: BCD
   4. 取出B, B->E
   5. MarkingQueue: BCDE
   6. 取出C, C-> F
   7. ...
4. 阶段 3：“对账” (Remark / Final Mark) - (有 STW，但“可控”)
   1. STW 停停停！
   2. 根据SATB Log对账(阶段2期间变更的引用(Old->Old/Young))，将记录的旧值作为GCRoots全量递归排查
5. 阶段4: Cleanup (清理) - (有 STW，但极短)
   1. （STW 期间）G1 经理（GC）现在有了“100% 准确”的“存活地图”。 
   2. 他遍历所有 Region，计算“垃圾比例”，生成一张 **“投资回报率 (ROI) 报表”** (即“建议表”)。 
   3. 他 **“顺便”** （在后台）“一键清空”那些“100% 都是垃圾”的 [Old] Region（白捡内存）。
6. 阶段5: “混合回收” (Mixed GC) - (N 次“小卡顿” STW)
   1. 打扫目标 (CSet): 
      1. [所有 Young Region] (和 Minor GC 一样)
      2. [“ROI报表”上“最划算”的 Old Region (比如 R8, R15)]
   2. GCRoots (起点): 
      1. Stack, Static, JNI (真的 GCRoots) 
      2. RSet (按需查询) (假的 GCRoots)
        > RSet (按需查询) 详解:
        > G1 会查询所有 CSet（Young + R8 + R15）的 RSet 账本。
        > 它查找所有“CSet 之外”指向“CSet 之内”的引用(只找OldRegion)。
        > 最终得到一个列表：(比如 Old -> Young, Old -> R8, Old -> R15)
   3. 扫描规则 (和 Minor GC 一样！“遇老则停”):
   4. 算法 (复制算法！):
      1. Young 活口 -> “复制” 到 [New S]
      2. R8, R15 活口 -> “复制” 到 [New O]
      3. “清空” (格式化) [All Young] + [R8] + [R15]。
      4. (STW 结束，只花了 20ms)