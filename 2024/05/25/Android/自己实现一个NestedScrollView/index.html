

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>自己实现一个NestedScrollView [ Swithun Blog ]</title>

  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/lib/font-awesome-4.7.0/css/font-awesome.min.css">
  
  <link rel="stylesheet" href="/lib/highlight-11-9-0/src/styles/atom-one-dark.css">
  
  <link rel="stylesheet" href="/css/again.css">
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>

  <!-- menu -->
  <div id="menu-outer">
    <div id="menu-inner">
      
      <a class="menu-button" href="/">Home</a>
      
      <a class="menu-button" href="/about">About</a>
      
      <a class="menu-button" href="/contact">Contact</a>
      
      <a class="menu-button" href="/archives">Archives</a>
      
      <a class="menu-button" href="/categories">Category</a>
      
    </div>
  </div>

  <!-- 中间主体 -->
  <div id="main">
    <!-- 侧边栏 -->
    <div id="aside-outer">
      <aside>
        <!-- 搜索栏 -->
<div id="search">
    <input class="search-input" type="text" placeholder="search">
    <i id="search-icon" class="fa fa-bars" title="切换目录与索引"></i>
</div>

<!-- 侧边目录栏 -->
<div id="tree">
    

    

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            Android
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/18/Android/Fragment原理/">
                            <i class="fa fa-file"></i>
                            Fragment原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/Android/viewmodel原理/">
                            <i class="fa fa-file"></i>
                            viewmodel原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/03/03/Android/view绘制原理/">
                            <i class="fa fa-file"></i>
                            view绘制原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/03/09/Android/自定义View实现拖拽展开面板/">
                            <i class="fa fa-file"></i>
                            自定义View实现拖拽展开面板
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/03/10/Android/Android窗口机制/">
                            <i class="fa fa-file"></i>
                            Android窗口机制
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/05/12/Android/NestedScrolling原理/">
                            <i class="fa fa-file"></i>
                            NestedScrolling原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file active">
                        <a href="/2024/05/25/Android/自己实现一个NestedScrollView/">
                            <i class="fa fa-file"></i>
                            自己实现一个NestedScrollView
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/06/02/Android/EditText光标定位原理/">
                            <i class="fa fa-file"></i>
                            EditText光标定位原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/06/02/Android/一步步解决NestedScrollView嵌套EditText的冲突/">
                            <i class="fa fa-file"></i>
                            一步步解决NestedScrollView嵌套EditText的冲突
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            主题演示
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/主题演示/demo1/">
                            <i class="fa fa-file"></i>
                            demo1
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/22/主题演示/temp/">
                            <i class="fa fa-file"></i>
                            temp
                        </a>
                    </li>
                </ul>

              

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            demo_folder_level2
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/主题演示/demo_folder_level2/demo2/">
                            <i class="fa fa-file"></i>
                            demo2
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 
</div>

<div id="toc" style="display: none;"></div>
      </aside>
    </div>
    <!-- 文章内容 -->
    <div id="content-outer">
      <div id="content-inner">
        
<article id="post">
  <h1>自己实现一个NestedScrollView</h1>
  <img src="/2024/05/25/Android/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AANestedScrollView/20240525130127.gif" class="" title="演示">

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a target="_blank" rel="noopener" href="https://github.com/swithun-liu/practice-android/tree/main/LearNestedScrolling">见github</a></p>
<h2 id="子view"><a href="#子view" class="headerlink" title="子view"></a>子view</h2><pre><code class="kotlin">import android.content.Context
import android.util.AttributeSet
import android.util.Log
import android.view.MotionEvent
import android.view.VelocityTracker
import android.view.ViewConfiguration
import android.widget.FrameLayout
import android.widget.OverScroller
import androidx.core.view.NestedScrollingChild3
import androidx.core.view.NestedScrollingChildHelper
import androidx.core.view.ViewCompat
import androidx.core.view.children

class ChildNestedScrollView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr), NestedScrollingChild3 &#123;

    private var lastTouchY = 0
    private var scrollConsumed = IntArray(2)
    private var scrollOffset = IntArray(2)
    private val childHelper by lazy &#123;
        NestedScrollingChildHelper(this).apply &#123; isNestedScrollingEnabled = true &#125;
    &#125;
    private var activePointerId = INVALID_POINTER

    // 第一个View
    private val firstView by lazy &#123;
        children.first()
    &#125;

    private val mScroller = OverScroller(context)

    override fun onTouchEvent(event: MotionEvent): Boolean &#123;
        val touchY = event.y.toInt()

        when (event.actionMasked) &#123;
            MotionEvent.ACTION_DOWN -&gt; &#123;
                // 停止fling
                run handleFling@&#123;
                    if (!mScroller.isFinished) &#123;
                        mScroller.abortAnimation()
                        stopNestedScroll(ViewCompat.TYPE_NON_TOUCH)
                    &#125;
                &#125;

                // 手动滚动处理
                run handleUserScroll@&#123;
                    lastTouchY = touchY
                    activePointerId = event.getPointerId(0)
                    startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, ViewCompat.TYPE_TOUCH)
                &#125;
            &#125;

            MotionEvent.ACTION_MOVE -&gt; &#123;
                Log.d(TAG, &quot;on ACTION_MOVE $lastTouchY $touchY&quot;)
                // 要滚多少
                val moveY = lastTouchY - touchY
                // 记录还能滚多少
                var unconsumedMoveY = moveY

                scrollConsumed[0] = 0
                scrollConsumed[1] = 0

                // [1] parent 滚吗
                run parentScrollFirst@ &#123;
                    when (dispatchNestedPreScroll(
                        0,
                        moveY,
                        scrollConsumed,
                        scrollOffset,
                        ViewCompat.TYPE_TOUCH
                    )) &#123;
                        // parent 滚
                        true -&gt; &#123;
                            Log.d(
                                TAG,
                                &quot;[onTouchEvent]#[dispatchNestedPreScroll]#true $moveY $&#123;scrollConsumed[1]&#125;&quot;
                            )
                            // 减去 parent消耗的
                            unconsumedMoveY -= scrollConsumed[1]
                        &#125;
                        // parent 不滚
                        false -&gt; &#123;
                            Log.d(
                                TAG,
                                &quot;[onTouchEvent]#[dispatchNestedPreScroll]#false $moveY $&#123;scrollConsumed[1]&#125;&quot;
                            )
                        &#125;
                    &#125;
                &#125;

                // [2] child 滚
                run childScrollNext@ &#123;
                    val parentConsumed = moveY - unconsumedMoveY

                    if (unconsumedMoveY != 0) &#123;
                        val childScroll = unconsumedMoveY
                        scrollBy(0, childScroll)
                        Log.d(TAG, &quot;[onTouchEvent]#[child scrollBy]#true $moveY $parentConsumed | $lastTouchY $touchY | $childScroll&quot;)
                        lastTouchY = touchY
                    &#125;
                &#125;

                run parentScrollFinal@ &#123;
                    // [3] child滚完了，如果剩下unconsumedMoveY，可以给parent滚
                    when (dispatchNestedScroll(
                        0,
                        moveY - unconsumedMoveY,
                        0,
                        unconsumedMoveY,
                        scrollOffset,
                        ViewCompat.TYPE_TOUCH,
                    )) &#123;
                        true -&gt; &#123;
                            Log.d(
                                TAG,
                                &quot;[onTouchEvent]#[dispatchNestedScroll]#true $scrollY $measuredHeight&quot;
                            )
                        &#125;

                        false -&gt; &#123;
                            Log.d(
                                TAG,
                                &quot;[onTouchEvent]#[dispatchNestedScroll]#false $scrollY $measuredHeight&quot;
                            )
                        &#125;
                    &#125;
                &#125;
            &#125;


            MotionEvent.ACTION_CANCEL,
            MotionEvent.ACTION_UP -&gt; &#123;
                // 停止滚动
                stopNestedScroll(ViewCompat.TYPE_TOUCH)

                // 开始fling
                velocityTracker.computeCurrentVelocity(1000, ViewConfiguration.get(context).scaledMaximumFlingVelocity.toFloat())
                val initialVelocity = velocityTracker.getYVelocity(activePointerId)
                fling(-initialVelocity)
                activePointerId = INVALID_POINTER
            &#125;


        &#125;
        velocityTracker.addMovement(event)
        return true
    &#125;

    private val velocityTracker = VelocityTracker.obtain()


    private fun fling(fl: Float) &#123;
        Log.d(TAG, &quot;fling $fl&quot;)
        mScroller.fling(
            scrollX, scrollY,
            0, fl.toInt(),
            0, 0,
            Int.MIN_VALUE, Int.MAX_VALUE,
            0, 0
        )
        startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, ViewCompat.TYPE_NON_TOUCH)
        mScroller.computeScrollOffset()
        rememberLastScrollerY = mScroller.currY
        scrollByScroller()
    &#125;

    private var rememberLastScrollerY = 0

    private fun scrollByScroller() &#123;
        postOnAnimation &#123;
           if (mScroller.isFinished)  return@postOnAnimation

            scrollConsumed[0] = 0
            scrollConsumed[1] = 0
            if (mScroller.computeScrollOffset()) &#123;
                val moveY = mScroller.currY - rememberLastScrollerY
                Log.d(TAG, &quot;[scrollByScroller]#[true] $&#123;mScroller.currY&#125; $rememberLastScrollerY [$moveY]&quot;)
                var unconsumedMoveY = moveY
                when (dispatchNestedPreScroll(
                    0,
                    moveY,
                    scrollConsumed,
                    scrollOffset,
                    ViewCompat.TYPE_NON_TOUCH
                )) &#123;
                    // parent 滚
                    true -&gt; &#123;
                        Log.d(
                            TAG,
                            &quot;[scrollByScroller]#[dispatchNestedPreScroll]#true $moveY $&#123;scrollConsumed[1]&#125;&quot;
                        )
                        // 减去 parent消耗的
                        unconsumedMoveY -= scrollConsumed[1]
                    &#125;
                    // parent 不滚
                    false -&gt; &#123;
                        Log.d(
                            TAG,
                            &quot;[scrollByScroller]#[dispatchNestedPreScroll]#false $moveY $&#123;scrollConsumed[1]&#125;&quot;
                        )
                    &#125;
                &#125;

                val parentConsumed = moveY - unconsumedMoveY

                // [2] child 滚
                if (unconsumedMoveY != 0) &#123;
                    val childScroll = unconsumedMoveY
                    scrollBy(0, childScroll)
                    Log.d(TAG, &quot;[onTouchEvent]#[child scrollBy]#true $moveY $parentConsumed| $childScroll&quot;)
                &#125;

                rememberLastScrollerY = mScroller.currY

                scrollByScroller()
            &#125; else &#123;

                Log.d(TAG, &quot;[scrollByScroller]#[false]&quot;)
            &#125;
        &#125;
    &#125;

    override fun startNestedScroll(axes: Int, type: Int): Boolean &#123;
        Log.i(TAG, &quot;child startNestedScroll axes:$axes type:$type &quot;)
        return childHelper.startNestedScroll(axes, type)
    &#125;

    override fun stopNestedScroll(type: Int) &#123;
        Log.i(TAG, &quot;child stopNestedScroll $type&quot;)
        childHelper.stopNestedScroll(type)
    &#125;

    override fun hasNestedScrollingParent(type: Int): Boolean &#123;
        return childHelper.hasNestedScrollingParent(type)
    &#125;

    override fun dispatchNestedScroll(
        dxConsumed: Int,
        dyConsumed: Int,
        dxUnconsumed: Int,
        dyUnconsumed: Int,
        offsetInWindow: IntArray?,
        type: Int,
        consumed: IntArray
    ) &#123;

    &#125;

    override fun dispatchNestedScroll(
        dxConsumed: Int,
        dyConsumed: Int,
        dxUnconsumed: Int,
        dyUnconsumed: Int,
        offsetInWindow: IntArray?,
        type: Int
    ): Boolean &#123;
        return childHelper.dispatchNestedScroll(
            dxConsumed,
            dyConsumed,
            dxUnconsumed,
            dyUnconsumed, offsetInWindow, type
        )
    &#125;

    override fun dispatchNestedPreScroll(
        dx: Int,
        dy: Int,
        consumed: IntArray?,
        offsetInWindow: IntArray?,
        type: Int
    ): Boolean &#123;
        return childHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type)
    &#125;

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;

        super.onMeasure(widthMeasureSpec, heightMeasureSpec)

        val height = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED)
        children.forEach &#123;
            measureChild(it, widthMeasureSpec, height)
        &#125;
    &#125;

    override fun scrollTo(x: Int, y: Int) &#123;
        val minY = 0
        val maxY = firstView.height - height
        when (val safeY = y.coerceIn(minY..maxY)) &#123;
            0 -&gt; Log.d(TAG, &quot;[scrollTo]#[false] $y  safeY$&#123;safeY&#125; $&#123;firstView.height&#125;&quot;)
            else -&gt; &#123;
                Log.d(TAG, &quot;[scrollTo]#[true] $y safeY$&#123;safeY&#125; $&#123;firstView.height&#125;&quot;)
                super.scrollTo(x, safeY)
            &#125;
        &#125;
    &#125;

    companion object &#123;
        private const val TAG = &quot;ChildNestedScrollView&quot;
        private const val INVALID_POINTER = -1
    &#125;

&#125;
</code></pre>
<h2 id="父View"><a href="#父View" class="headerlink" title="父View"></a>父View</h2><pre><code class="kotlin">import android.content.Context
import android.util.AttributeSet
import android.util.Log
import android.view.View
import android.widget.FrameLayout
import androidx.core.view.NestedScrollingParent3
import androidx.core.view.NestedScrollingParentHelper
import androidx.core.view.children

class ParentNestedScrollView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr), NestedScrollingParent3 &#123;

    private val parentHelper by lazy &#123;
        NestedScrollingParentHelper(this)
    &#125;

    // 第一个View
    private val firstView by lazy &#123;
        children.first()
    &#125;

    override fun onStartNestedScroll(child: View, target: View, axes: Int, type: Int): Boolean &#123;
        return true
    &#125;

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;
        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED))
    &#125;

    override fun onNestedScrollAccepted(child: View, target: View, axes: Int, type: Int) &#123;
        Log.i(TAG, &quot;[onNestedScrollAccepted] $type&quot;)
        parentHelper.onNestedScrollAccepted(child, target, axes, type)
    &#125;

    override fun onStopNestedScroll(target: View, type: Int) &#123;
        Log.i(TAG, &quot;[onStopNestedScroll] $type&quot;)
        parentHelper.onStopNestedScroll(target, type)
    &#125;

    override fun onNestedScroll(
        target: View,
        dxConsumed: Int,
        dyConsumed: Int,
        dxUnconsumed: Int,
        dyUnconsumed: Int,
        type: Int,
        consumed: IntArray
    ) &#123;
        Log.i(TAG, &quot;[onNestedScroll]&quot;)
    &#125;

    override fun onNestedScroll(
        target: View,
        dxConsumed: Int,
        dyConsumed: Int,
        dxUnconsumed: Int,
        dyUnconsumed: Int,
        type: Int
    ) &#123;
        Log.i(TAG, &quot;[onNestedScroll]2&quot;)
    &#125;

    override fun onNestedPreScroll(target: View, dx: Int, dy: Int, consumed: IntArray, type: Int) &#123;

        val parentWantToConsume = dy / 2
        val nextY = scrollY + parentWantToConsume
        val maxNextY = (firstView.height - height)
        val minNextY = 0
        val safeNextY = nextY.coerceIn(minNextY..maxNextY)

        when (val safePrentWantToConsume = safeNextY - scrollY) &#123;
            0 -&gt; Log.i(TAG, &quot;[onNestedPreScroll]#false ($type)&quot;)
            else -&gt; &#123;
                Log.i(TAG, &quot;[onNestedPreScroll]#true ($type) $&#123;scrollY&#125; $&#123;firstView.height&#125;&quot;)
                consumed[1] = safePrentWantToConsume
                scrollBy(0, safePrentWantToConsume)
            &#125;
        &#125;
    &#125;

    override fun scrollTo(x: Int, y: Int) &#123;
        if (y &gt;= 0 &amp;&amp; y &lt;= (firstView.height - height)) &#123;
            Log.d(TAG, &quot;[scrollTo]#[true] $y $&#123;firstView.height&#125;&quot;)
            super.scrollTo(x, y)
        &#125; else &#123;
            Log.d(TAG, &quot;[scrollTo]#[false] $y $&#123;firstView.height&#125;&quot;)
        &#125;
    &#125;

    companion object &#123;
        private const val TAG = &quot;ParentNestedScrollView&quot;
    &#125;

&#125;
</code></pre>

</article>

<script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<div id="paginator">
  
</div>

      </div>
    </div>

  </div>

  <!-- 底部信息 -->
  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Swithun Liu using
      <a target="_blank" rel="noopener" href="http://hexo.io">hexo blog framework</a>.
      <br>
      <a href="/">Home</a>
    </div>
  </div>


  
  <!-- scripts list from theme config.yml -->
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.0-alpha1/highlight.min.js"></script>
  
  <script src="/lib/jquery-3.4.1.min.js"></script>
  
  <script src="/lib/jquery.pjax.js"></script>
  
  <script src="/js/again.js"></script>
  
  


  <!-- 高亮脚本启动 -->
  <script>hljs.initHighlightingOnLoad();</script>

    <!-- 如果设置中mermaid选项打开 -->
    
    <!-- 引入mermaid脚本 -->
    <div class=".pjax-reload">
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.0.0-alpha.4/mermaid.min.js'></script>
    </div>
    <!-- mermaid启动 -->
    <script>
      if (window.mermaid) {
        mermaid.initialize({ theme: 'dark' });
      }
    </script>
    

</body>

</html>