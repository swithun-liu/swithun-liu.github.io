

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>view绘制原理 [ Swithun Blog ]</title>

  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/lib/font-awesome-4.7.0/css/font-awesome.min.css">
  
  <link rel="stylesheet" href="/lib/highlight-11-9-0/src/styles/atom-one-dark.css">
  
  <link rel="stylesheet" href="/css/again.css">
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>

  <!-- menu -->
  <div id="menu-outer">
    <div id="menu-inner">
      
      <a class="menu-button" href="/">Home</a>
      
      <a class="menu-button" href="/about">About</a>
      
      <a class="menu-button" href="/contact">Contact</a>
      
      <a class="menu-button" href="/archives">Archives</a>
      
      <a class="menu-button" href="/categories">Category</a>
      
    </div>
  </div>

  <!-- 中间主体 -->
  <div id="main">
    <!-- 侧边栏 -->
    <div id="aside-outer">
      <aside>
        <!-- 搜索栏 -->
<div id="search">
    <input class="search-input" type="text" placeholder="search">
    <i id="search-icon" class="fa fa-bars" title="切换目录与索引"></i>
</div>

<!-- 侧边目录栏 -->
<div id="tree">
    

    

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            Android
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/18/Android/Fragment原理/">
                            <i class="fa fa-file"></i>
                            Fragment原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/Android/viewmodel原理/">
                            <i class="fa fa-file"></i>
                            viewmodel原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file active">
                        <a href="/2024/03/03/Android/view绘制原理/">
                            <i class="fa fa-file"></i>
                            view绘制原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/03/09/Android/自定义View实现拖拽展开面板/">
                            <i class="fa fa-file"></i>
                            自定义View实现拖拽展开面板
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            主题演示
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/主题演示/demo1/">
                            <i class="fa fa-file"></i>
                            demo1
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/22/主题演示/temp/">
                            <i class="fa fa-file"></i>
                            temp
                        </a>
                    </li>
                </ul>

              

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            demo_folder_level2
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/主题演示/demo_folder_level2/demo2/">
                            <i class="fa fa-file"></i>
                            demo2
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 
</div>

<div id="toc" style="display: none;"></div>
      </aside>
    </div>
    <!-- 文章内容 -->
    <div id="content-outer">
      <div id="content-inner">
        
<article id="post">
  <h1>view绘制原理</h1>
  <pre class="mermaid">flowchart TD
DecoreView
ViewGroup
ViewGroup2["ViewGroup"]
View1["View"]
View2["View"]
View3["View"]
View4["View"]

DecoreView --> |自上而下刷新|ViewGroup
ViewGroup --> ViewGroup2
ViewGroup --> View1
ViewGroup --> View2
ViewGroup2--> View3
ViewGroup2 --> View4</pre>


<ul>
<li>[1709475090] <code>invalidate</code></li>
</ul>
<pre><code class="java">// android.view.View
    @UnsupportedAppUsage
    public void invalidate(boolean invalidateCache) &#123;
       [1709475107] invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);
    &#125;
</code></pre>
<ul>
<li>[1709475107] <code>invalidateInternal</code></li>
</ul>
<pre><code class="java">// android.view.View
    void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,
            boolean fullInvalidate) &#123;
        if (mGhostView != null) &#123;
            mGhostView.invalidate(true);
            return;
        &#125;

        if (skipInvalidate()) &#123;
            return;
        &#125;

        // Reset content capture caches
        mPrivateFlags4 &amp;= ~PFLAG4_CONTENT_CAPTURE_IMPORTANCE_MASK;
        mContentCaptureSessionCached = false;

        if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)
                || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)
                || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED
                || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;
            if (fullInvalidate) &#123;
                mLastIsOpaque = isOpaque();
                mPrivateFlags &amp;= ~PFLAG_DRAWN;
            &#125;

            [1709477262] mPrivateFlags |= PFLAG_DIRTY;

            if (invalidateCache) &#123;
                mPrivateFlags |= PFLAG_INVALIDATED;
                mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;
            &#125;

            // Propagate the damage rectangle to the parent view.
            final AttachInfo ai = mAttachInfo;
            [1709475296] final ViewParent p = mParent;
            if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;
                final Rect damage = ai.mTmpInvalRect;
                [1709479770] damage.set(l, t, r, b);
                [1709475402] p.invalidateChild(this, damage);
            &#125;

            // Damage the entire projection receiver, if necessary.
            if (mBackground != null &amp;&amp; mBackground.isProjected()) &#123;
                final View receiver = getProjectionReceiver();
                if (receiver != null) &#123;
                    receiver.damageInParent();
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<p>[1709479625]l, r, t, b传入的就是调用invalidate的View 需要重绘的区域，注意这里传入的 l, r都是0，t是宽，b是高度，所以传入的不是相对 mParent 的位置。</p>
<ul>
<li>[1709477262] <code>mPrivateFlags |= PFLAG_DIRTY;</code></li>
</ul>
<p>标记dirty——<code>View</code>正在被重绘</p>
<ul>
<li>[1709479770] <code>damage.set(l, t, r, b);</code></li>
</ul>
<p>设置重绘区域, l,t,r,b来自[1709479625]</p>
<ul>
<li>[1709475296] <code>final ViewParent p = mParent</code></li>
</ul>
<p>这个View所附加到的父级View</p>
<pre><code class="java">// android.view.View
    /**
     * The parent this view is attached to.
     * &#123;@hide&#125;
     *
     * @see #getParent()
     */
    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)
    protected ViewParent mParent;
</code></pre>
<ul>
<li>[1709475402] <code>p.invalidateChild(this, damage)</code></li>
</ul>
<p>子视图的全部或部分内容已变脏，需要重新绘制。</p>
<pre><code class="java">// android.view.ViewParent
    /**
     * All or part of a child is dirty and needs to be redrawn.
     * 
     * @param child The child which is dirty
     * @param r The area within the child that is invalid
     *
     * @deprecated Use &#123;@link #onDescendantInvalidated(View, View)&#125; instead.
     */
    @Deprecated
    public void invalidateChild(View child, Rect r);
</code></pre>
<p>实现该方法的<code>ViewParent</code>实现类只有<code>ViewGroup</code></p>
<pre class="mermaid">classDiagram
class ViewGroup
class ViewParent {
    <<interface>>
}
ViewGroup --|> ViewParent: impl</pre>

<ul>
<li>[1709475903] <code>ViewGroup.invalidateChild</code></li>
</ul>
<pre><code class="java">//android.view.ViewGroup 
    @Deprecated
    @Override
    public final void invalidateChild(View child, final Rect dirty) &#123;
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null &amp;&amp; attachInfo.mHardwareAccelerated) &#123;
            // HW accelerated fast path
            onDescendantInvalidated(child, child);
            return;
        &#125;

        [1709476329] ViewParent parent = this;
        if (attachInfo != null) &#123;
            // If the child is drawing an animation, we want to copy this flag onto
            // ourselves and the parent to make sure the invalidate request goes
            // through
            final boolean drawAnimation = (child.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != 0;

            // Check whether the child that requests the invalidate is fully opaque
            // Views being animated or transformed are not considered opaque because we may
            // be invalidating their old position and need the parent to paint behind them.
            Matrix childMatrix = child.getMatrix();
            // Mark the child as dirty, using the appropriate flag
            // Make sure we do not set both flags at the same time

            if (child.mLayerType != LAYER_TYPE_NONE) &#123;
                mPrivateFlags |= PFLAG_INVALIDATED;
                mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;
            &#125;

            final int[] location = attachInfo.mInvalidateChildLocation;
            location[CHILD_LEFT_INDEX] = child.mLeft;
            location[CHILD_TOP_INDEX] = child.mTop;
            if (!childMatrix.isIdentity() ||
                    (mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123;
                RectF boundingRect = attachInfo.mTmpTransformRect;
                boundingRect.set(dirty);
                Matrix transformMatrix;
                if ((mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123;
                    Transformation t = attachInfo.mTmpTransformation;
                    boolean transformed = getChildStaticTransformation(child, t);
                    if (transformed) &#123;
                        transformMatrix = attachInfo.mTmpMatrix;
                        transformMatrix.set(t.getMatrix());
                        if (!childMatrix.isIdentity()) &#123;
                            transformMatrix.preConcat(childMatrix);
                        &#125;
                    &#125; else &#123;
                        transformMatrix = childMatrix;
                    &#125;
                &#125; else &#123;
                    transformMatrix = childMatrix;
                &#125;
                transformMatrix.mapRect(boundingRect);
                dirty.set((int) Math.floor(boundingRect.left),
                        (int) Math.floor(boundingRect.top),
                        (int) Math.ceil(boundingRect.right),
                        (int) Math.ceil(boundingRect.bottom));
            &#125;

            do &#123;
                View view = null;
                if (parent instanceof View) &#123;
                    view = (View) parent;
                &#125;

                if (drawAnimation) &#123;
                    if (view != null) &#123;
                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                    &#125; else if (parent instanceof ViewRootImpl) &#123;
                        ((ViewRootImpl) parent).mIsAnimating = true;
                    &#125;
                &#125;

                // If the parent is dirty opaque or not dirty, mark it dirty with the opaque
                // flag coming from the child that initiated the invalidate
                if (view != null) &#123;
                    if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;
                        view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DIRTY;
                    &#125;
                &#125;

                [1709476371] parent = parent.invalidateChildInParent(location, dirty);
                if (view != null) &#123;
                    // Account for transform on current parent
                    Matrix m = view.getMatrix();
                    if (!m.isIdentity()) &#123;
                        RectF boundingRect = attachInfo.mTmpTransformRect;
                        boundingRect.set(dirty);
                        m.mapRect(boundingRect);
                        dirty.set((int) Math.floor(boundingRect.left),
                                (int) Math.floor(boundingRect.top),
                                (int) Math.ceil(boundingRect.right),
                                (int) Math.ceil(boundingRect.bottom));
                    &#125;
                &#125;
            &#125; while (parent != null);
        &#125;
    &#125;
</code></pre>
<ul>
<li>[1709476371] <code>parent = parent.invalidateChildInParent(location, dirty);</code></li>
</ul>
<p>最开始parent就是View的mParent - ViewGroup自己 <code>[1709476329] ViewParent parent = this;</code><br>不断循环，pareng赋值为<code>invalidateChildInParent</code>的返回值</p>
<ul>
<li>[1709476540] <code>ViewParent.invalidateChildInParent(int[] location, Rect r)</code></li>
</ul>
<pre><code class="java">// android.view.ViewParent
    @Deprecated
    public ViewParent invalidateChildInParent(int[] location, Rect r);
</code></pre>
<pre><code class="java">//android.view.ViewGroup 
    @Deprecated
    @Override
    public ViewParent invalidateChildInParent(final int[] location, final Rect dirty) &#123;
        if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != 0) &#123;
            // either DRAWN, or DRAWING_CACHE_VALID
            if ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE))
                    != FLAG_OPTIMIZE_INVALIDATE) &#123;
                [1709480037] dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,
                        location[CHILD_TOP_INDEX] - mScrollY);
                if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == 0) &#123;
                    [1709481021] dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
                &#125;

                final int left = mLeft;
                final int top = mTop;

                if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;
                    if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) &#123;
                        dirty.setEmpty();
                    &#125;
                &#125;

                location[CHILD_LEFT_INDEX] = left;
                location[CHILD_TOP_INDEX] = top;
            &#125; else &#123;

                if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;
                    dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
                &#125; else &#123;
                    // in case the dirty rect extends outside the bounds of this container
                    dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
                &#125;
                location[CHILD_LEFT_INDEX] = mLeft;
                location[CHILD_TOP_INDEX] = mTop;

                mPrivateFlags &amp;= ~PFLAG_DRAWN;
            &#125;
            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;
            if (mLayerType != LAYER_TYPE_NONE) &#123;
                mPrivateFlags |= PFLAG_INVALIDATED;
            &#125;

            return mParent;
        &#125;

        return null;
    &#125;
</code></pre>
<ul>
<li>[1709480037] <code>dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);</code></li>
</ul>
<p>[1709479625]说过传入的重绘区域不是相对父布局的位置，所以这里转换为相对父布局(当前View)的位置;<br>这里还考虑的mScrollX，和mScrollY，因为子View可能已经不在可视区域了</p>
<ul>
<li>[1709481021] <code>dirty.union(0, 0, mRight - mLeft, mBottom - mTop);</code></li>
</ul>
<p>[1709480037]将重绘位置转换为相对相对父布局(当前View)的位置，然后与当前View的绘制范围取交集，所以union之后一定&lt;&#x3D;之前传入的重绘范围，比如子View已经滚出当前ViewGroup，那就没有要重绘的区域了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6854573222386958344">View Invalidate流程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127673/4252441">android invalidate 执行流程详解</a></li>
</ul>

</article>

<script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<div id="paginator">
  
</div>

      </div>
    </div>

  </div>

  <!-- 底部信息 -->
  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Swithun Liu using
      <a target="_blank" rel="noopener" href="http://hexo.io">hexo blog framework</a>.
      <br>
      <a href="/">Home</a>
    </div>
  </div>


  
  <!-- scripts list from theme config.yml -->
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.0-alpha1/highlight.min.js"></script>
  
  <script src="/lib/jquery-3.4.1.min.js"></script>
  
  <script src="/lib/jquery.pjax.js"></script>
  
  <script src="/js/again.js"></script>
  
  


  <!-- 高亮脚本启动 -->
  <script>hljs.initHighlightingOnLoad();</script>

    <!-- 如果设置中mermaid选项打开 -->
    
    <!-- 引入mermaid脚本 -->
    <div class=".pjax-reload">
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.0.0-alpha.4/mermaid.min.js'></script>
    </div>
    <!-- mermaid启动 -->
    <script>
      if (window.mermaid) {
        mermaid.initialize({ theme: 'dark' });
      }
    </script>
    

</body>

</html>