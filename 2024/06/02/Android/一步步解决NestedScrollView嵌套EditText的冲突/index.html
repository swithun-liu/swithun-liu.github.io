

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>一步步解决NestedScrollView嵌套EditText的冲突 [ Swithun Blog ]</title>

  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/lib/font-awesome-4.7.0/css/font-awesome.min.css">
  
  <link rel="stylesheet" href="/lib/highlight-11-9-0/src/styles/atom-one-dark.css">
  
  <link rel="stylesheet" href="/css/again.css">
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>

  <!-- menu -->
  <div id="menu-outer">
    <div id="menu-inner">
      
      <a class="menu-button" href="/">Home</a>
      
      <a class="menu-button" href="/about">About</a>
      
      <a class="menu-button" href="/contact">Contact</a>
      
      <a class="menu-button" href="/archives">Archives</a>
      
      <a class="menu-button" href="/categories">Category</a>
      
    </div>
  </div>

  <!-- 中间主体 -->
  <div id="main">
    <!-- 侧边栏 -->
    <div id="aside-outer">
      <aside>
        <!-- 搜索栏 -->
<div id="search">
    <input class="search-input" type="text" placeholder="search">
    <i id="search-icon" class="fa fa-bars" title="切换目录与索引"></i>
</div>

<!-- 侧边目录栏 -->
<div id="tree">
    

    

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            Android
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/18/Android/Fragment原理/">
                            <i class="fa fa-file"></i>
                            Fragment原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/Android/viewmodel原理/">
                            <i class="fa fa-file"></i>
                            viewmodel原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/03/03/Android/view绘制原理/">
                            <i class="fa fa-file"></i>
                            view绘制原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/03/09/Android/自定义View实现拖拽展开面板/">
                            <i class="fa fa-file"></i>
                            自定义View实现拖拽展开面板
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/03/10/Android/Android窗口机制/">
                            <i class="fa fa-file"></i>
                            Android窗口机制
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/05/12/Android/NestedScrolling原理/">
                            <i class="fa fa-file"></i>
                            NestedScrolling原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/05/25/Android/自己实现一个NestedScrollView/">
                            <i class="fa fa-file"></i>
                            自己实现一个NestedScrollView
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/06/02/Android/EditText光标定位原理/">
                            <i class="fa fa-file"></i>
                            EditText光标定位原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file active">
                        <a href="/2024/06/02/Android/一步步解决NestedScrollView嵌套EditText的冲突/">
                            <i class="fa fa-file"></i>
                            一步步解决NestedScrollView嵌套EditText的冲突
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/06/11/Android/Dialog原理/">
                            <i class="fa fa-file"></i>
                            Dialog原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/07/20/Android/从0实现一个BottomSheetDialog/">
                            <i class="fa fa-file"></i>
                            从0实现一个BottomSheetDialog
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/08/18/Android/kotlin协程原理/">
                            <i class="fa fa-file"></i>
                            kotlin协程原理
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/09/07/Android/textview measure流程/">
                            <i class="fa fa-file"></i>
                            textview measure流程
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            主题演示
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/主题演示/demo1/">
                            <i class="fa fa-file"></i>
                            demo1
                        </a>
                    </li>
                </ul>

              
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/22/主题演示/temp/">
                            <i class="fa fa-file"></i>
                            temp
                        </a>
                    </li>
                </ul>

              

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            demo_folder_level2
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2023/10/10/主题演示/demo_folder_level2/demo2/">
                            <i class="fa fa-file"></i>
                            demo2
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            AOSP
                        </a>
                        

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            java
                        </a>
                        

                <!--如果是文件夹-->
                <ul>
                    <li class="directory">
                        <a href="#" class="directory">
                            <i class="fa fa-folder"></i>
                            lang
                        </a>
                        
                <!--如果是文章-->
                <ul>
                    <li class="file">
                        <a href="/2024/10/07/AOSP/java/lang/ThreadLocal/">
                            <i class="fa fa-file"></i>
                            ThreadLocal
                        </a>
                    </li>
                </ul>

              
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 
                    </li>
                </ul>

                 
</div>

<div id="toc" style="display: none;"></div>
      </aside>
    </div>
    <!-- 文章内容 -->
    <div id="content-outer">
      <div id="content-inner">
        
<article id="post">
  <h1>一步步解决NestedScrollView嵌套EditText的冲突</h1>
  <h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/20240610210256.gif" class="" title="alt text">

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><pre><code class="xml">        &lt;activity
            android:name=&quot;.MainActivity&quot;
            android:windowSoftInputMode=&quot;adjustResize|stateAlwaysHidden&quot;
            android:exported=&quot;true&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
</code></pre>
<pre><code class="kotlin">class MainActivity : AppCompatActivity() &#123;
    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContentView(R.layout.activity_main)
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            val ime = insets.getInsets(WindowInsetsCompat.Type.ime())
            v.setPadding(v.paddingLeft, v.paddingTop, v.paddingRight, ime.bottom - ime.top)
            insets
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/image.png" class="" title="alt text">

<ul>
<li>NestedScrollView<ul>
<li>LinearLayout<ul>
<li>3: NestedScrollEditText(这个是这次的例子，最后说)</li>
<li>1: 这个是直接放一个EditText的情况</li>
<li>2: 这个是NestedScrollView嵌套一个EditText的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>windowSoftInputMode 设置为 adjustResize</li>
<li>通过设置 contentView 的根view(R.id.main) 的底部padding 留出键盘高度，防止键盘遮挡</li>
</ol>
<h2 id="方案一：直接放EditText"><a href="#方案一：直接放EditText" class="headerlink" title="方案一：直接放EditText"></a>方案一：直接放EditText</h2><img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/20240610182205.gif" class="" title="alt text">

<p>存在问题：</p>
<ol>
<li>EditText 内容无法滚动</li>
<li>即是可以滚动，也没有fling效果</li>
</ol>
<p>对于问题1，</p>
<pre><code class="java">// NestedScrollView
    @Override
    public boolean onInterceptTouchEvent(@NonNull MotionEvent ev) &#123;
        ...
        final int action = ev.getAction();
        if ((action == MotionEvent.ACTION_MOVE) &amp;&amp; mIsBeingDragged) &#123;
            return true;
        &#125;
</code></pre>
<p>这里move事件会被NestedScrollView拦截，导致EditText内部无法滚动</p>
<p>这里可以通过处理onInterceptTouchEvent等方式让EditText可以滚动，但是EditText没有fling效果，所以放弃这个方案。</p>
<h2 id="方案二：NestedScrollView嵌套EditText"><a href="#方案二：NestedScrollView嵌套EditText" class="headerlink" title="方案二：NestedScrollView嵌套EditText"></a>方案二：NestedScrollView嵌套EditText</h2><img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/20240610191306.gif" class="" title="alt text">

<p>存在问题</p>
<ol>
<li>点击EditText，弹出键盘，EditText会滚到屏幕最上面</li>
<li>滚动EditText内容到下方，点击EditText，弹出键盘，EditText会被键盘遮挡</li>
</ol>
<h2 id="方案三：NestedScrollViewEditText"><a href="#方案三：NestedScrollViewEditText" class="headerlink" title="方案三：NestedScrollViewEditText"></a>方案三：NestedScrollViewEditText</h2><p>基于方案二优化</p>
<pre><code class="kotlin">class NestedScrollEditText @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : NestedScrollView(context, attrs, defStyleAttr) &#123;

    protected val editText: NestedScrollEditTextInner = NestedScrollEditTextInner(context).also &#123;
        it.isFocusableInTouchMode = true
    &#125;

    ...

    init &#123;
        editText.setText(
            &quot;萨萨是...到发到发&quot;
        )
        this.addView(
            editText,
            LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)
        )
    &#125;

    inner class NestedScrollEditTextInner @JvmOverloads constructor(
        context: Context,
        attrs: AttributeSet? = null,
        defStyleAttr: Int = 0
    ) : AppCompatEditText(context, attrs, defStyleAttr) &#123;
        ...
    &#125;

&#125;
</code></pre>
<pre><code class="kotlin">class AsParentNestedScrollView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : NestedScrollView(context, attrs, defStyleAttr) &#123;

&#125;
</code></pre>
<p>结构: </p>
<ul>
<li>AsParentNestedScrollView(替换到最外层的NestedScrollView)<ul>
<li>NestedScrollEditTest(实际上是NestedScrollView)<ul>
<li>NestedScrollEditTextInner(实际上是EditText)</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/image4.png" class="" title="alt text">

<h3 id="问题1-展开键盘EditText会不符合预期的滚动到可见区域上方-被键盘遮挡"><a href="#问题1-展开键盘EditText会不符合预期的滚动到可见区域上方-被键盘遮挡" class="headerlink" title="问题1: 展开键盘EditText会不符合预期的滚动到可见区域上方&#x2F;被键盘遮挡"></a>问题1: 展开键盘EditText会不符合预期的滚动到可见区域上方&#x2F;被键盘遮挡</h3><p>这个是因为键盘展开时会调整contentView的paddingBottom，导致NestedScrollView高度变化</p>
<pre><code class="java">// NestedScrollView
    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;
        // 这里会尝试将当前focus的View滚动到可见位置
    &#125;
</code></pre>
<p>所以这里覆写onSizedChanged——什么都不做 ⬇️</p>
<pre><code class="kotlin">class AsParentNestedScrollView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : NestedScrollView(context, attrs, defStyleAttr) &#123;

    /**
     * ScrollView大小变化后，会找有没有focus的view，则会滚动到focus的EditText处
     */
    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123;
    &#125;
</code></pre>
<img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/20240610192550.gif" class="" title="alt text">

<p>存在问题：EditText首次获取焦点时还是会滚动到最上面，之后就好了(保持原来的位置，虽然会被遮挡)</p>
<pre><code class="java">// NestedScrollView
    @Override
    public void requestChildFocus(View child, View focused) &#123;
        ...
            // 当EditText获取焦点时，会最终走到外层的`requestChildFocus`方法，这里会滚动到被focused的View
            scrollToChild(focused);
        ...
        super.requestChildFocus(child, focused);
    &#125;
</code></pre>
<p>这里当获取焦点时的自动滚动并不符合我们的预期，滚动后的位置离键盘太远</p>
<pre><code class="kotlin">class AsParentNestedScrollView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : NestedScrollView(context, attrs, defStyleAttr) &#123;

    /**
     * EditText requestFocus 会调用 parent的的requestChildFocus，NestedScrollView会自动滚动到focus child
     * 但是这里的没有考虑光标位置，导致不符合预期
     * 通过 [isRequestingChildFocus] 强制让 [computeScrollDeltaToGetChildRectOnScreen]——此次的滚动delta变为0
     */
    override fun requestChildFocus(child: View?, focused: View?) &#123;
        isRequestingChildFocus = true
        super.requestChildFocus(child, focused)
        isRequestingChildFocus = false
    &#125;

    override fun computeScrollDeltaToGetChildRectOnScreen(rect: Rect?): Int &#123;
        return if (isRequestingChildFocus) &#123;
            0
        &#125; else &#123;
            super.computeScrollDeltaToGetChildRectOnScreen(rect)
        &#125;
    &#125;
&#125;
</code></pre>
<p>解决方式⬆️：由于父类并没有暴露一些变量，也无法直接调用 <code>super.super.requestChildFocus</code>，这里只要用一个变量记录 <code>isRequestingChildFocus</code>，<code>requestChildFocus</code> 会调用  <code>computeScrollDeltaToGetChildRectOnScreen</code> 计算滚动到哪里，所以这里强制让他返回 0，就不会滚动。</p>
<h3 id="问题2-让NesteScrollEditText贴在键盘上面"><a href="#问题2-让NesteScrollEditText贴在键盘上面" class="headerlink" title="问题2: 让NesteScrollEditText贴在键盘上面"></a>问题2: 让NesteScrollEditText贴在键盘上面</h3><p>解决问题一之后，虽然不会不符合预期的自动滚动到奇怪的位置，但是会被键盘遮挡</p>
<img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/20240610194927.gif" class="" title="alt text">

<p>⬆️测试发现，虽然点击editText展开键盘时内容会被遮挡，但是只要继续输入内容就会自动滚动到那一行，这是如何实现的⬇️？</p>
<pre><code class="java">// TextView
    // 当输入内容时，会调用到该方法
    public boolean bringPointIntoView(int offset) &#123;
        return bringPointIntoView(offset, false);
    &#125;
</code></pre>
<pre><code class="java">// TextView
    public boolean bringPointIntoView(@IntRange(from = 0) int offset,
            boolean requestRectWithoutFocus) &#123;

            // 选中区域(光标位置左边，选中行上方，光标位置右边，选中行下方)
            mTempRect.set(x - 2, top, x + 2, bottom);
            // 这里根据选中区域 判断用户想要看第几行（不考虑scroll），这里会覆盖掉mTempRect
            getInterestingRect(mTempRect, line);
            // TextView内部可能滚动，上一步第几行没有考虑scroll，所以真正显示的位置需要考虑scorll
            mTempRect.offset(mScrollX, mScrollY);


            // 请求将选中区域滚为可见
            if (requestRectangleOnScreen(mTempRect)) 
            ...
    &#125;
</code></pre>
<pre><code class="java">// TextView
    public boolean requestRectangleOnScreen(Rect rectangle, boolean immediate) &#123;
        if (mParent == null) &#123;
            return false;
        &#125;

        View child = this;

        // 2. position 用来记录 child 对于 parent的相对位置(child parent 会递归向上改变具体指向的view)
        RectF position = (mAttachInfo != null) ? mAttachInfo.mTmpTransformRect : new RectF();
        position.set(rectangle);

        ViewParent parent = mParent;
        boolean scrolled = false;

        // 0. 让parent滚动，从而让EditText可见，一层层的递归向上
        while (parent != null) &#123;
            rectangle.set((int) position.left, (int) position.top,
                    (int) position.right, (int) position.bottom);

            // parent 根据child请求可见的位置(相对child的位置)，尝试滚动让其区域可见
            scrolled |= parent.requestChildRectangleOnScreen(child, rectangle, immediate);

            if (!(parent instanceof View)) &#123;
                break;
            &#125;

            // 考虑child的top 以及 child的scroll，偏移后才是child在parent上想要显示的区域，即 相对child的位置 转换成 相对parent的位置
            position.offset(child.mLeft - child.getScrollX(), child.mTop -child.getScrollY());

            // parent变成child
            child = (View) parent;
            // parent再找parent的parent
            parent = child.getParent();
        &#125;

        return scrolled;
    &#125;
</code></pre>
<p>上面会不断找parent，再尝试让parent滚动自身让请求可见区域可见，比如NestedScrollView 对 <code>requestChildRectangleOnScreen</code> 的处理如下</p>
<pre><code class="java">    public boolean requestChildRectangleOnScreen(@NonNull View child, Rect rectangle,
            boolean immediate) &#123;
        // 将 `相对child的位置` 转换为 `相对NestedScrollView` 的相对位置
        rectangle.offset(child.getLeft() - child.getScrollX(),
                child.getTop() - child.getScrollY());

        // 滚动至处理后的请求位置可见
        return scrollToChildRect(rectangle, immediate);
    &#125;
</code></pre>
<p>所以只需要在键盘弹出后再调用一遍 <code>bringPointIntoView</code> 即可</p>
<pre><code class="kotlin">class MainActivity : AppCompatActivity() &#123;
    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContentView(R.layout.activity_main)
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            val ime = insets.getInsets(WindowInsetsCompat.Type.ime())
            v.setPadding(v.paddingLeft, v.paddingTop, v.paddingRight, ime.bottom - ime.top)
            // 开始
            v.post &#123; // 等padding生效后，重新调用一次bringPointIntoView(editText自己其实也会调用一次，但是是在set padding之前)
                findViewById&lt;NestedScrollEditText&gt;(R.id.editText).bringPointIntoView()
            &#125;
            // 结束
            insets
        &#125;
    &#125;
&#125;
</code></pre>
<p>处理后的效果</p>
<img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/20240610205327.gif" class="" title="alt text">


<h3 id="问题3-希望光标行和键盘顶部有一段距离"><a href="#问题3-希望光标行和键盘顶部有一段距离" class="headerlink" title="问题3: 希望光标行和键盘顶部有一段距离"></a>问题3: 希望光标行和键盘顶部有一段距离</h3><img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/image2.png" class="" title="alt text">

<p>假设红框⬆️区域有一个确认按钮，如果像下图⬇️，光标行紧贴键盘顶部，则会遮挡按钮</p>
<img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/image3.png" class="" title="alt text">

<p>在解决问题2的时候，已经知道弹出键盘&#x2F;输入内容时光标行是如何自动定位的，不断告诉parent想要请求可见的位置，所以这里思路就是NestedScrollEditTextInner给NestedScrollEditText的请求可见位置是正常的，当NestedScrollEditText告诉它的parent(AsParentNestedScrollView)请求可见位置修改一下，将请求可见位置底部变成NestedScrollEditText的底部+额外给按钮流出的高度</p>
<pre><code class="kotlin">// NestedScrollEditText
        override fun requestRectangleOnScreen(rectangle: Rect, immediate: Boolean): Boolean &#123;
            val copyRect = Rect(rectangle)
            // 这里先正常走super的方法
            val scrolled = super.requestRectangleOnScreen(rectangle, immediate)

            val parentRect = Rect(copyRect)
            val parent = parent as NestedScrollEditText
            parent.post &#123; // 这里一定要post，上面 immediate是false，所以parent.scrollY没有立即生效
                parentRect.bottom = parent.scrollY + parent.height + bottomGapPx
                parent.requestRectangleOnScreen(parentRect)
            &#125;
            return scrolled
        &#125;
</code></pre>
<p>最终效果</p>
<img src="/2024/06/02/Android/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3NestedScrollView%E5%B5%8C%E5%A5%97EditText%E7%9A%84%E5%86%B2%E7%AA%81/20240610210256.gif" class="" title="alt text">


<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a target="_blank" rel="noopener" href="https://github.com/swithun-liu/practice-android/tree/main/NesteScrollEditText">见github</a></p>
<pre><code class="kotlin">class MainActivity : AppCompatActivity() &#123;
    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContentView(R.layout.activity_main)
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            val ime = insets.getInsets(WindowInsetsCompat.Type.ime())
            v.setPadding(v.paddingLeft, v.paddingTop, v.paddingRight, ime.bottom - ime.top)
            v.post &#123; // 等padding生效后，重新调用一次bringPointIntoView(editText自己其实也会调用一次，但是是在set padding之前)
                findViewById&lt;NestedScrollEditText&gt;(R.id.editText).bringPointIntoView()
            &#125;
            insets
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="kotlin">import android.content.Context
import android.util.AttributeSet
import android.view.ViewGroup
import androidx.appcompat.widget.AppCompatEditText
import androidx.core.widget.NestedScrollView
import android.graphics.Rect

class NestedScrollEditText @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : NestedScrollView(context, attrs, defStyleAttr) &#123;

    protected val editText: NestedScrollEditTextInner = NestedScrollEditTextInner(context).also &#123;
        it.isFocusableInTouchMode = true
    &#125;

    protected var bottomGapPx = 200

    init &#123;
        editText.setText(
            &quot;萨萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发到发是的发送到发送到发送到发送到发送到发送到发送到发送到发送萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发萨是的发送到发送到发送到发送到发送到发送到发送到发送到发送到发到发&quot;
        )
        this.addView(
            editText,
            LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)
        )
    &#125;


    fun bringPointIntoView(): Boolean &#123;

        val offset = editText.selectionStart
        editText.bringPointIntoView(offset)

        return true
    &#125;

    inner class NestedScrollEditTextInner @JvmOverloads constructor(
        context: Context,
        attrs: AttributeSet? = null,
        defStyleAttr: Int = 0
    ) : AppCompatEditText(context, attrs, defStyleAttr) &#123;


        /** 禁止内部EdiText的滚动 */
        override fun scrollTo(x: Int, y: Int) &#123;
        &#125;

        override fun requestRectangleOnScreen(rectangle: Rect, immediate: Boolean): Boolean &#123;
            val copyRect = Rect(rectangle)
            val scrolled = super.requestRectangleOnScreen(rectangle, immediate)

            val parentRect = Rect(copyRect)
            val parent = parent as NestedScrollEditText
            parent.post &#123; // 这里一定要post，上面 immediate是false，所以parent.scrollY没有立即生效
                parentRect.bottom = parent.scrollY + parent.height + bottomGapPx
                parent.requestRectangleOnScreen(parentRect)
            &#125;
            return scrolled
        &#125;

    &#125;


&#125;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/main&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;com.swithun.nestedscrolledittext.nestedscroledittext.AsParentNestedScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;LinearLayout
            android:orientation=&quot;vertical&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;

            &lt;View
                android:background=&quot;#FFBFBF&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;150dp&quot;/&gt;

            &lt;View
                android:background=&quot;#FFD5BF&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;150dp&quot;/&gt;

            &lt;View
                android:background=&quot;#FFF1BF&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;150dp&quot;/&gt;

            &lt;View
                android:background=&quot;#BFE3FF&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;150dp&quot;/&gt;

            &lt;TextView
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:text=&quot;NestedScrollEditText ⬇️&quot;
                /&gt;

            &lt;com.swithun.nestedscrolledittext.nestedscroledittext.NestedScrollEditText
                android:id=&quot;@+id/editText&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;300dp&quot; /&gt;

            &lt;View
                android:background=&quot;#BFC2FF&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;150dp&quot;/&gt;

            &lt;TextView
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:text=&quot;EditText ⬇️&quot;
                /&gt;

            &lt;androidx.appcompat.widget.AppCompatEditText
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;200dp&quot;
                android:text=&quot;我我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分JKIk&quot;
                /&gt;

            &lt;View
                android:background=&quot;#CDBFFF&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;150dp&quot;/&gt;

            &lt;TextView
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:text=&quot;NestedScrollView + EditText ⬇️&quot;
                /&gt;

            &lt;androidx.core.widget.NestedScrollView
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;200dp&quot;&gt;

                &lt;androidx.appcompat.widget.AppCompatEditText
                    android:layout_width=&quot;match_parent&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:text=&quot;我我是第三个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分我是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分是第二个发大发到发送到发短发短发短发多少发多少发到发送到发多少发送到发多少发多少分JKIk&quot;
                    /&gt;

            &lt;/androidx.core.widget.NestedScrollView&gt;

            &lt;View
                android:background=&quot;#EEBFFF&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;150dp&quot;/&gt;

            &lt;View
                android:background=&quot;#E9FFBF&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;150dp&quot;/&gt;

            &lt;View
                android:background=&quot;#BFFFF0&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;150dp&quot;/&gt;

        &lt;/LinearLayout&gt;

    &lt;/com.swithun.nestedscrolledittext.nestedscroledittext.AsParentNestedScrollView&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>

</article>

<script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<div id="paginator">
  
</div>

      </div>
    </div>

  </div>

  <!-- 底部信息 -->
  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Swithun Liu using
      <a target="_blank" rel="noopener" href="http://hexo.io">hexo blog framework</a>.
      <br>
      <a href="/">Home</a>
    </div>
  </div>


  
  <!-- scripts list from theme config.yml -->
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.0-alpha1/highlight.min.js"></script>
  
  <script src="/lib/jquery-3.4.1.min.js"></script>
  
  <script src="/lib/jquery.pjax.js"></script>
  
  <script src="/js/again.js"></script>
  
  


  <!-- 高亮脚本启动 -->
  <script>hljs.initHighlightingOnLoad();</script>

    <!-- 如果设置中mermaid选项打开 -->
    
    <!-- 引入mermaid脚本 -->
    <div class=".pjax-reload">
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.0.0-alpha.4/mermaid.min.js'></script>
    </div>
    <!-- mermaid启动 -->
    <script>
      if (window.mermaid) {
        mermaid.initialize({ theme: 'dark' });
      }
    </script>
    

</body>

</html>